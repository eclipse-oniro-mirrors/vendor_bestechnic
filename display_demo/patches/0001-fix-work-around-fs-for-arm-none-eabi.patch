From 7dfffc55b24860d96a7d300092c4b50428fb1ae6 Mon Sep 17 00:00:00 2001
From: SimonLi <likailong@huawei.com>
Date: Sat, 27 Nov 2021 14:27:09 +0800
Subject: [PATCH] kernel/liteos_m

Change-Id: I9562ce01e7a627aca1a770c4a929cff9d55320c7
---
 BUILD.gn                                      |   43 -
 Kconfig                                       |   42 +-
 arch/arm/cortex-m33/gcc/NTZ/los_interrupt.c   |    2 +-
 components/fs/BUILD.gn                        |   23 +-
 components/fs/Kconfig                         |   32 +
 components/fs/fatfs/Kconfig                   |   72 +-
 components/fs/fatfs/fatfs.c                   |  586 +++----
 components/fs/fatfs/fatfs.h                   |    7 +-
 components/fs/fs.c                            |  549 -------
 components/fs/littlefs/Kconfig                |   51 +
 components/fs/littlefs/lfs_api.c              |  520 +++---
 components/fs/littlefs/lfs_api.h              |    9 +-
 components/fs/vfs/BUILD.gn                    |   47 +
 components/fs/vfs/Kconfig                     |   34 +
 components/fs/vfs/fs.c                        | 1449 +++++++++++++++++
 components/fs/vfs/fs_conf.h                   |   47 +
 components/fs/vfs/fs_files.c                  |  108 ++
 components/fs/vfs/fs_files.h                  |  120 ++
 components/fs/vfs/fs_init.c                   |   51 +
 components/fs/vfs/fs_maps.c                   |  124 ++
 components/fs/vfs/fs_maps.h                   |   71 +
 components/fs/vfs/fs_mount.c                  |  259 +++
 components/fs/vfs/fs_mount.h                  |   88 +
 components/fs/{ => vfs}/fs_operations.h       |   46 +-
 components/fs/vfs/los_fs.h                    |   92 ++
 components/fs/vfs/partition.c                 |  191 +++
 components/fs/vfs/partition.h                 |   65 +
 components/fs/{ => vfs}/vfs_config.h          |   69 +-
 .../net/lwip-2.1/porting/include/arch/cc.h    |    4 -
 .../lwip-2.1/porting/src/sockets_porting.c    |    2 +-
 kal/BUILD.gn                                  |   15 +-
 kal/Kconfig                                   |   32 +
 kal/cmsis/Kconfig                             |   36 +
 kal/libc/BUILD.gn                             |   35 +
 kal/libc/Kconfig                              |   44 +
 kal/libc/musl/BUILD.gn                        |   46 +
 kal/libc/musl/Kconfig                         |   39 +
 kal/libc/musl/fs.c                            |  146 ++
 kal/{posix/src => libc/musl}/malloc.c         |  160 +-
 kal/libc/newlib/BUILD.gn                      |   56 +
 kal/libc/newlib/Kconfig                       |   39 +
 kal/libc/newlib/porting/include/dirent.h      |   56 +
 kal/libc/newlib/porting/include/dlfcn.h       |   42 +
 kal/libc/newlib/porting/include/endian.h      |   10 +
 kal/libc/newlib/porting/include/limits.h      |   13 +
 kal/libc/newlib/porting/include/mqueue.h      |   35 +
 kal/libc/newlib/porting/include/net/if.h      |  142 ++
 kal/libc/newlib/porting/include/netinet/in.h  |  415 +++++
 kal/libc/newlib/porting/include/netinet/ip.h  |  199 +++
 kal/libc/newlib/porting/include/semaphore.h   |   28 +
 .../porting/include/sys/_pthreadtypes.h       |  112 ++
 kal/libc/newlib/porting/include/sys/fcntl.h   |   12 +
 .../newlib/porting/include/sys/features.h     |   54 +
 kal/libc/newlib/porting/include/sys/ioctl.h   |  238 +++
 kal/libc/newlib/porting/include/sys/mount.h   |   55 +
 kal/libc/newlib/porting/include/sys/prctl.h   |  167 ++
 kal/libc/newlib/porting/include/sys/sched.h   |   24 +
 kal/libc/newlib/porting/include/sys/socket.h  |  413 +++++
 kal/libc/newlib/porting/include/sys/statfs.h  |   30 +
 kal/libc/newlib/porting/include/sys/uio.h     |   40 +
 kal/libc/newlib/porting/include/time.h        |   10 +
 kal/libc/newlib/porting/src/fs_adapt.c        |  146 ++
 kal/libc/newlib/porting/src/other_adapt.c     |  111 ++
 kal/libc/newlib/porting/src/realpath.c        |   76 +
 kal/libc/newlib/porting/src/time_adapt.c      |   54 +
 kal/posix/BUILD.gn                            |   37 +-
 kal/posix/Kconfig                             |   62 +
 kal/posix/src/pthread_cond.c                  |   28 +-
 kal/posix/src/time.c                          |   49 +-
 kernel/src/los_init.c                         |    8 +
 70 files changed, 6580 insertions(+), 1537 deletions(-)
 create mode 100644 components/fs/Kconfig
 delete mode 100644 components/fs/fs.c
 create mode 100644 components/fs/littlefs/Kconfig
 create mode 100644 components/fs/vfs/BUILD.gn
 create mode 100644 components/fs/vfs/Kconfig
 create mode 100644 components/fs/vfs/fs.c
 create mode 100644 components/fs/vfs/fs_conf.h
 create mode 100644 components/fs/vfs/fs_files.c
 create mode 100644 components/fs/vfs/fs_files.h
 create mode 100644 components/fs/vfs/fs_init.c
 create mode 100644 components/fs/vfs/fs_maps.c
 create mode 100644 components/fs/vfs/fs_maps.h
 create mode 100644 components/fs/vfs/fs_mount.c
 create mode 100644 components/fs/vfs/fs_mount.h
 rename components/fs/{ => vfs}/fs_operations.h (60%)
 create mode 100644 components/fs/vfs/los_fs.h
 create mode 100644 components/fs/vfs/partition.c
 create mode 100644 components/fs/vfs/partition.h
 rename components/fs/{ => vfs}/vfs_config.h (61%)
 create mode 100644 kal/Kconfig
 create mode 100644 kal/cmsis/Kconfig
 create mode 100644 kal/libc/BUILD.gn
 create mode 100644 kal/libc/Kconfig
 create mode 100644 kal/libc/musl/BUILD.gn
 create mode 100644 kal/libc/musl/Kconfig
 create mode 100644 kal/libc/musl/fs.c
 rename kal/{posix/src => libc/musl}/malloc.c (97%)
 create mode 100644 kal/libc/newlib/BUILD.gn
 create mode 100644 kal/libc/newlib/Kconfig
 create mode 100644 kal/libc/newlib/porting/include/dirent.h
 create mode 100644 kal/libc/newlib/porting/include/dlfcn.h
 create mode 100644 kal/libc/newlib/porting/include/endian.h
 create mode 100644 kal/libc/newlib/porting/include/limits.h
 create mode 100644 kal/libc/newlib/porting/include/mqueue.h
 create mode 100644 kal/libc/newlib/porting/include/net/if.h
 create mode 100644 kal/libc/newlib/porting/include/netinet/in.h
 create mode 100644 kal/libc/newlib/porting/include/netinet/ip.h
 create mode 100644 kal/libc/newlib/porting/include/semaphore.h
 create mode 100644 kal/libc/newlib/porting/include/sys/_pthreadtypes.h
 create mode 100644 kal/libc/newlib/porting/include/sys/fcntl.h
 create mode 100644 kal/libc/newlib/porting/include/sys/features.h
 create mode 100644 kal/libc/newlib/porting/include/sys/ioctl.h
 create mode 100644 kal/libc/newlib/porting/include/sys/mount.h
 create mode 100644 kal/libc/newlib/porting/include/sys/prctl.h
 create mode 100644 kal/libc/newlib/porting/include/sys/sched.h
 create mode 100644 kal/libc/newlib/porting/include/sys/socket.h
 create mode 100644 kal/libc/newlib/porting/include/sys/statfs.h
 create mode 100644 kal/libc/newlib/porting/include/sys/uio.h
 create mode 100644 kal/libc/newlib/porting/include/time.h
 create mode 100644 kal/libc/newlib/porting/src/fs_adapt.c
 create mode 100644 kal/libc/newlib/porting/src/other_adapt.c
 create mode 100644 kal/libc/newlib/porting/src/realpath.c
 create mode 100644 kal/libc/newlib/porting/src/time_adapt.c
 create mode 100644 kal/posix/Kconfig

diff --git a/BUILD.gn b/BUILD.gn
index fa0ac5d..f912361 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -244,8 +244,6 @@ config("public") {
       configs += [ "$device_path:public" ]
     }
   }
-
-  configs += [ "$LITEOSTHIRDPARTY/musl/porting/liteos_m/kernel:include" ]
 }
 
 group("modules") {
@@ -267,8 +265,6 @@ group("modules") {
       deps += [ device_path ]
     }
   }
-
-  deps += [ "$LITEOSTHIRDPARTY/musl/porting/liteos_m/kernel" ]
 }
 
 # when HAVE_DEVICE_SDK is not reached, gn raises an error. so we just use it as
@@ -293,42 +289,3 @@ group("kernel") {
 group("liteos_m") {
 }
 
-executable("liteos") {
-  configs += [
-    ":public",
-    ":los_config",
-  ]
-
-  ldflags = [
-    "-static",
-    "-Wl,--gc-sections",
-    "-Wl,-Map=$liteos_name.map",
-  ]
-
-  output_dir = target_out_dir
-
-  if (liteos_kernel_only) {
-    deps = [ ":kernel" ]
-  } else {
-    deps = [ "//build/lite:ohos" ]
-  }
-}
-
-copy("copy_liteos") {
-  deps = [ ":liteos" ]
-  sources = [ "$target_out_dir/unstripped/bin/liteos" ]
-  outputs = [ "$root_out_dir/$liteos_name" ]
-}
-
-build_ext_component("build_kernel_image") {
-  deps = [ ":copy_liteos" ]
-  exec_path = rebase_path(root_out_dir)
-
-  objcopy = "${compile_prefix}objcopy$toolchain_cmd_suffix"
-  objdump = "${compile_prefix}objdump$toolchain_cmd_suffix"
-
-  command = "$objcopy -O binary $liteos_name $liteos_name.bin"
-  command +=
-      " && sh -c '$objdump -t $liteos_name | sort >$liteos_name.sym.sorted'"
-  command += " && sh -c '$objdump -d $liteos_name >$liteos_name.asm'"
-}
diff --git a/Kconfig b/Kconfig
index 0f80f4a..db7ce4a 100644
--- a/Kconfig
+++ b/Kconfig
@@ -370,53 +370,15 @@ endmenu
 
 ######################### config options of compatibility ##############
 menu "Compat"
-config  COMPAT_POSIX
-    bool "Enable Posix"
-    default y
-
-    help
-      Answer Y to enable LiteOS support posix interface.
-
-config  COMPAT_CMSIS
-    bool "Enable CMSIS v2"
-    default n
 
-    help
-      Answer Y to enable LiteOS support CMSIS v2 interface.
+rsource "kal/Kconfig"
 
 endmenu
 
 ######################## config options of filesystem ##################
 menu "FileSystem"
-config FS_VFS
-    bool "Enable VFS"
-    default y
-
-    help
-      Answer Y to enable LiteOS support virtual filesystem.
-
-source "components/fs/fatfs/Kconfig"
 
-config FS_LITTLEFS
-    bool "Enable littlefs"
-    default n
-    depends on FS_VFS
-    select SUPPORT_LITTLEFS
-    help
-      Answer Y to enable LiteOS support littlefs.
-
-config LFS_MAX_MOUNT_SIZE
-    int "Littlefs max mounts"
-    default 3
-    depends on FS_LITTLEFS
-
-config SUPPORT_FATFS
-    bool
-    default n
-
-config SUPPORT_LITTLEFS
-    bool
-    default n
+rsource "components/fs/Kconfig"
 
 endmenu
 
diff --git a/arch/arm/cortex-m33/gcc/NTZ/los_interrupt.c b/arch/arm/cortex-m33/gcc/NTZ/los_interrupt.c
index 489abf2..2aa8a55 100755
--- a/arch/arm/cortex-m33/gcc/NTZ/los_interrupt.c
+++ b/arch/arm/cortex-m33/gcc/NTZ/los_interrupt.c
@@ -513,7 +513,7 @@ LITE_OS_SEC_TEXT_INIT VOID HalHwiInit(VOID)
     *(volatile UINT32 *)OS_NVIC_SHCSR |= (USGFAULT | BUSFAULT | MEMFAULT);
 	
     /* Enable DIV 0 and unaligned exception */
-    *(volatile UINT32 *)OS_NVIC_CCR |= (DIV0FAULT | UNALIGNFAULT);
+    *(volatile UINT32 *)OS_NVIC_CCR |= (DIV0FAULT);
 
     return;
 }
diff --git a/components/fs/BUILD.gn b/components/fs/BUILD.gn
index 3078c16..f3139dc 100644
--- a/components/fs/BUILD.gn
+++ b/components/fs/BUILD.gn
@@ -29,24 +29,7 @@
 
 import("//kernel/liteos_m/liteos.gni")
 
-module_switch = defined(LOSCFG_FS_VFS)
-module_name = "fs_operations"
-kernel_module(module_name) {
-  sources = [ "fs.c" ]
-}
-
-group("fs") {
-  deps = [ ":$module_name" ]
-  deps += [
-    "fatfs",
-    "littlefs",
-  ]
-}
-
-config("public") {
-  include_dirs = [ "." ]
-  configs = [
-    "fatfs:public",
-    "littlefs:public",
-  ]
+module_name = get_path_info(rebase_path("."), "name")
+module_group(module_name) {
+  modules = [ "vfs", "littlefs", "fatfs" ]
 }
diff --git a/components/fs/Kconfig b/components/fs/Kconfig
new file mode 100644
index 0000000..e036939
--- /dev/null
+++ b/components/fs/Kconfig
@@ -0,0 +1,32 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+rsource "vfs/Kconfig"
+rsource "littlefs/Kconfig"
+rsource "fatfs/Kconfig"
\ No newline at end of file
diff --git a/components/fs/fatfs/Kconfig b/components/fs/fatfs/Kconfig
index 1d401bb..637b30e 100644
--- a/components/fs/fatfs/Kconfig
+++ b/components/fs/fatfs/Kconfig
@@ -1,45 +1,45 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
 config FS_FAT
-    bool "Enable FAT"
+    bool "Enable FAT FS"
     default n
     depends on FS_VFS
-    select SUPPORT_FATFS
-    select COMPAT_CMSIS
     help
       Answer Y to enable LiteOS support fat filesystem.
 
-config FS_FAT_CACHE
-    bool "Enable FAT Cache"
-    default y
-    depends on FS_FAT
-    help
-      Answer Y to enable LiteOS fat filesystem support cache.
-
-config FS_FAT_CACHE_SYNC_THREAD
-    bool "Enable FAT Cache Sync Thread"
-    default n
-    depends on FS_FAT_CACHE
-    help
-      Answer Y to enable LiteOS fat filesystem support cache sync thread.
+if FS_FAT
 
-config FS_FAT_CHINESE
-    bool "Enable Chinese"
-    default y
-    depends on FS_FAT
+config FAT_FS_MAX_OPEN_FILES
+    int "Maximum number of opened files"
+    default 50
     help
-      Answer Y to enable LiteOS fat filesystem support Chinese.
-
-config FS_FAT_VIRTUAL_PARTITION
-    bool "Enabel Virtual Partition"
-    default n
-    depends on FS_FAT
-
-config FS_FAT_VOLUMES
-    int
-    depends on FS_FAT
-    default 32 if PLATFORM_HI3731
-    default 16
+        This is a global maximum across all mounted littlefs filesystems.
 
-config FS_FAT_DISK
-    bool "Enable partinfo for storage device"
-    depends on FS_FAT
-    default y
+endif # FS_LITTLEFS
diff --git a/components/fs/fatfs/fatfs.c b/components/fs/fatfs/fatfs.c
index 02e4f24..fdf0653 100644
--- a/components/fs/fatfs/fatfs.c
+++ b/components/fs/fatfs/fatfs.c
@@ -36,12 +36,14 @@
 #include "stdbool.h"
 #include "limits.h"
 #include "pthread.h"
+#include "partition.h"
 #include "time.h"
 #include "securec.h"
 #include "los_compiler.h"
 #include "los_debug.h"
 #include "cmsis_os2.h"
 #include "fs_operations.h"
+#include "fs_files.h"
 
 /* the max name length of different parts should not bigger than 32 */
 #define FS_DRIVE_NAME_MAX_LEN 32
@@ -59,22 +61,17 @@
 #define PATH_NAME   0x2
 #define NAME_MASK   0x3
 
-typedef struct {
-    UINT8 useFlag;
-    FIL fil;
-} FatHandleStruct;
-
-static FatHandleStruct g_handle[FAT_MAX_OPEN_FILES] = {0};
-static DIR g_dir[FAT_MAX_OPEN_DIRS] = {0};
 static FATFS g_fatfs[FF_VOLUMES] = {0};
 static UINT8 g_workBuffer[FF_MAX_SS];
-static UINT32 g_fileNum = 0;
-static UINT32 g_dirNum = 0;
-static struct dirent g_retValue;
-static pthread_mutex_t g_fsMutex = PTHREAD_MUTEX_INITIALIZER;
-
-static const char * const g_volPath[FF_VOLUMES] = {FF_VOLUME_STRS};
-static BOOL g_volWriteEnable[FF_VOLUMES] = {FALSE};
+static pthread_mutex_t g_fatfsMutex = PTHREAD_MUTEX_INITIALIZER;
+static char * g_volPath[FF_VOLUMES] = {FF_VOLUME_STRS};
+
+PARTITION VolToPart[] = {
+    { 0, 0, 1, 0, 0 },
+    { 0, 0, 2, 0, 0 },
+    { 0, 0, 3, 0, 0 },
+    { 0, 0, 4, 0, 0 }
+};
 
 static int FsLock(void)
 {
@@ -89,7 +86,7 @@ static int FsLock(void)
         return errno;
     }
     absTimeout.tv_sec += FS_LOCK_TIMEOUT_SEC;
-    ret = pthread_mutex_timedlock(&g_fsMutex, &absTimeout);
+    ret = pthread_mutex_timedlock(&g_fatfsMutex, &absTimeout);
     return ret;
 }
 
@@ -98,24 +95,17 @@ static void FsUnlock(void)
     if (osKernelGetState() != osKernelRunning) {
         return;
     }
-    (void)pthread_mutex_unlock(&g_fsMutex);
-}
-
-static bool IsValidFd(int fd)
-{
-    if ((fd < 0) || (fd >= FAT_MAX_OPEN_FILES) || (g_handle[fd].useFlag == 0)) {
-        return false;
-    }
-    return true;
+    (void)pthread_mutex_unlock(&g_fatfsMutex);
 }
 
 static int FsChangeDrive(const char *path)
 {
     INT32 res;
-    CHAR tmpPath[FS_DRIVE_NAME_MAX_LEN] = { "/" }; /* the max name length of different parts is 16 */
     errno_t retErr;
-    UINT16 pathLen;
-    pathLen = strlen((char const *)path);
+    UINT16 pathLen = strlen((char const *)path);
+    /* the max name length of different parts is 16 */
+    CHAR tmpPath[FS_DRIVE_NAME_MAX_LEN] = { "/" };
+
     /* make sure the path begin with "/", the path like /xxx/yyy/... */
     if (pathLen >= (FS_DRIVE_NAME_MAX_LEN - 1)) {
         /* 2: except first flag "/" and last end flag */
@@ -174,27 +164,21 @@ static int FsPartitionMatch(const char *path, int flag)
     return FS_FAILURE;
 }
 
-static int Remount(const char *path, unsigned long mountflags)
+static int Remount(struct MountPoint *mp, unsigned long mountflags)
 {
-    INT32 index;
-
-    index = FsPartitionMatch(path, PART_NAME);
-    if (index == FS_FAILURE) {
-        PRINTK("Wrong volume path!\r\n");
-        errno = ENOENT;
-        return FS_FAILURE;
-    }
+    FATFS *fatfs = (FATFS *)mp->mData;
 
     /* remount is not allowed when the device is not mounted. */
-    if (g_fatfs[index].fs_type == 0) {
+    if (fatfs->fs_type == 0) {
         errno = EINVAL;
         return FS_FAILURE;
     }
-    g_volWriteEnable[index] = (mountflags & MS_RDONLY) ? FALSE : TRUE;
+    mp->mWriteEnable = (mountflags & MS_RDONLY) ? FALSE : TRUE;
 
     return FS_SUCCESS;
 }
 
+#if 0
 static bool FsCheckByPath(const char *path)
 {
     INT32 index;
@@ -204,7 +188,7 @@ static bool FsCheckByPath(const char *path)
         return FS_FAILURE;
     }
 
-    return g_volWriteEnable[index];
+    return mp->mWriteEnable;
 }
 
 static bool FsCheckByID(int id)
@@ -213,11 +197,12 @@ static bool FsCheckByID(int id)
 
     for (index = 0; index < FF_VOLUMES; index++) {
         if (g_fatfs[index].id == id) {
-            return g_volWriteEnable[index];
+            return mp->mWriteEnable;
         }
     }
     return false;
 }
+#endif
 
 static unsigned int FatFsGetMode(int oflags)
 {
@@ -318,7 +303,81 @@ static int FatfsErrno(int result)
     return status;
 }
 
-int fatfs_mount(const char *source, const char *target,
+char * GetLdPath(const char *source)
+{
+    int volId = -1;
+    int partId = GetPartIdByPartName(source);
+    if (partId < 0 || partId >= 4) {
+        return NULL;
+    }
+
+    volId = partId;
+    return g_volPath[volId];
+}
+
+int FatfsMount(struct MountPoint *mp, const char *source,
+    unsigned long mountflags, const void *data)
+{
+    FRESULT res;
+    INT32 ret;
+    FATFS *fs = NULL;
+    int volId;
+    char *ldrvPath = NULL;
+
+    ret = FsLock();
+    if (ret != 0) {
+        errno = ret;
+        return FS_FAILURE;
+    }
+
+    if (mountflags & MS_REMOUNT) {
+        ret = Remount(mp, mountflags);
+        goto OUT;
+    }
+
+    fs = (FATFS *)malloc(sizeof(FATFS));
+    if (fs == NULL) {
+        errno = ENOMEM;
+        return FS_FAILURE;
+    }
+    (void)memset_s(fs, sizeof(FATFS), 0, sizeof(FATFS));
+
+    mp->mData = (void *)fs;
+
+#if 0
+    /*
+     * source->partId(volId)->ldpath(ldNum), more detail:
+     *
+     * source is something like "mmcblk0p0", "p0" can indicate
+     * that 0 is the "volId", volId can finally parse ldpath from user's
+     * fatfs config.
+     */
+    ldrvPath = GetLdPath(source);
+#endif
+    volId = FsPartitionMatch(mp->mPath, VOLUME_NAME);
+    if (volId == FS_FAILURE) {
+        errno = ENOENT;
+        ret = FS_FAILURE;
+        goto OUT;
+    }
+    ldrvPath =  g_volPath[volId];
+
+    res = f_mount((FATFS *)mp->mData, ldrvPath, 1);
+    if (res != FR_OK) {
+        errno = FatfsErrno(res);
+        ret = FS_FAILURE;
+        goto OUT;
+    }
+
+    ret = FS_SUCCESS;
+
+OUT:
+    FsUnlock();
+    return ret;
+}
+
+#if 0
+int FatfsMount(const char *source, const char *target,
                 const char *filesystemtype, unsigned long mountflags,
                 const void *data)
 {
@@ -369,19 +428,21 @@ int fatfs_mount(const char *source, const char *target,
         goto OUT;
     }
 
-    g_volWriteEnable[index] = (mountflags & MS_RDONLY) ? FALSE : TRUE;
+    mp->mWriteEnable = (mountflags & MS_RDONLY) ? FALSE : TRUE;
     ret = FS_SUCCESS;
 
 OUT:
     FsUnlock();
     return ret;
 }
+#endif
 
-int fatfs_umount(const char *target)
+int FatfsUmount(struct MountPoint *mp, const char *target)
 {
     FRESULT res;
     INT32 ret;
-    INT32 index;
+    INT32 volId;
+    FATFS *fatfs = (FATFS *)mp->mData;
 
     if (target == NULL) {
         errno = EFAULT;
@@ -394,22 +455,22 @@ int fatfs_umount(const char *target)
         return FS_FAILURE;
     }
 
-    index = FsPartitionMatch(target, VOLUME_NAME);
-    if (index == FS_FAILURE) {
+    volId = FsPartitionMatch(target, VOLUME_NAME);
+    if (volId == FS_FAILURE) {
         errno = ENOENT;
         ret = FS_FAILURE;
         goto OUT;
     }
 
     /* The volume is not mounted */
-    if (g_fatfs[index].fs_type == 0) {
+    if (fatfs->fs_type == 0) {
         errno = EINVAL;
         ret = FS_FAILURE;
         goto OUT;
     }
 
     /* umount is not allowed when a file or diretory is opened. */
-    if (f_checkopenlock(index) != FR_OK) {
+    if (f_checkopenlock(volId) != FR_OK) {
         errno = EBUSY;
         ret = FS_FAILURE;
         goto OUT;
@@ -422,12 +483,13 @@ int fatfs_umount(const char *target)
         goto OUT;
     }
 
-    if (g_fatfs[index].win != NULL) {
-        ff_memfree(g_fatfs[index].win);
+#if 0
+    if (g_fatfs[volId].win != NULL) {
+        ff_memfree(g_fatfs[volId].win);
     }
+#endif
 
-    (void)memset_s(&g_fatfs[index], sizeof(FATFS), 0x0, sizeof(FATFS));
-
+    free(mp->mData);
     ret = FS_SUCCESS;
 
 OUT:
@@ -435,12 +497,13 @@ OUT:
     return ret;
 }
 
+#if 0
 static int CloseAll(int index)
 {
     INT32 i;
     FRESULT res;
 
-    for (i = 0; i < FAT_MAX_OPEN_FILES; i++) {
+    for (i = 0; i < FAT_FS_MAX_OPEN_FILES; i++) {
         if (g_fileNum <= 0) {
             break;
         }
@@ -472,13 +535,15 @@ static int CloseAll(int index)
 
     return FS_SUCCESS;
 }
+#endif
 
-int fatfs_umount2(const char *target, int flag)
+int FatfsUmount2(struct MountPoint *mp, const char *target, int flag)
 {
     INT32 index;
     INT32 ret;
     UINT32 flags;
     FRESULT res;
+    FATFS *fatfs = (FATFS *)mp->mData;
 
     if (target == NULL) {
         errno = EFAULT;
@@ -505,18 +570,20 @@ int fatfs_umount2(const char *target, int flag)
     }
 
     /* The volume is not mounted */
-    if (g_fatfs[index].fs_type == 0) {
+    if (fatfs->fs_type == 0) {
         errno = EINVAL;
         ret = FS_FAILURE;
         goto OUT;
     }
 
+#if 0
     if ((UINT32)flag & MNT_FORCE) {
         ret = CloseAll(index);
         if (ret != FS_SUCCESS) {
             goto OUT;
         }
     }
+#endif
 
     res = f_mount((FATFS *)NULL, target, 0);
     if (res != FR_OK) {
@@ -525,11 +592,13 @@ int fatfs_umount2(const char *target, int flag)
         goto OUT;
     }
 
+#if 0
     if (g_fatfs[index].win != NULL) {
         ff_memfree(g_fatfs[index].win);
     }
+#endif
 
-    (void)memset_s(&g_fatfs[index], sizeof(FATFS), 0x0, sizeof(FATFS));
+    free(mp->mData);
     ret = FS_SUCCESS;
 
 OUT:
@@ -537,14 +606,12 @@ OUT:
     return ret;
 }
 
-int fatfs_open(const char *path, int oflag, ...)
+int FatfsOpen(struct File *file, const char *path, int oflag)
 {
     FRESULT res;
-    UINT32 i;
-    UINT32 openNum = 0;
     UINT32 fmode;
     INT32 ret;
-    FILINFO fileInfo = {0};
+    FIL *fp = NULL;
 
     if (path == NULL) {
         errno = EFAULT;
@@ -553,33 +620,18 @@ int fatfs_open(const char *path, int oflag, ...)
 
     fmode = FatFsGetMode(oflag);
 
+    fp = (FIL *)malloc(sizeof(FIL));
+    if (fp == NULL) {
+        errno = ENOMEM;
+        return FS_FAILURE;
+    }
+
     ret = FsLock();
     if (ret != 0) {
         errno = ret;
         return FS_FAILURE;
     }
 
-    if (g_fileNum >= FAT_MAX_OPEN_FILES) {
-        PRINTK("FAT g_fileNum is out of range 0x%x!\r\n", g_fileNum);
-        errno = ENFILE;
-        ret = FS_FAILURE;
-        goto OUT;
-    }
-
-    for (i = 0; i < FAT_MAX_OPEN_FILES; i++) {
-        if (g_handle[i].useFlag == 0) {
-            openNum = i;
-            break;
-        }
-    }
-
-    if (i >= FAT_MAX_OPEN_FILES) {
-        PRINTK("FAT opennum is out of range 0x%x!\r\n", openNum);
-        errno = ENFILE;
-        ret = FS_FAILURE;
-        goto OUT;
-    }
-
     ret = FsChangeDrive(path);
     if (ret != FS_SUCCESS) {
         PRINTK("FAT open ChangeDrive err 0x%x!\r\n", ret);
@@ -588,6 +640,7 @@ int fatfs_open(const char *path, int oflag, ...)
         goto OUT;
     }
 
+#if 0
     /* cannot creat a new file in the write protected part */
     if ((((UINT32)oflag & O_CREAT) != 0) && (!FsCheckByPath(path))) {
         res = f_stat(path, &fileInfo);
@@ -598,29 +651,29 @@ int fatfs_open(const char *path, int oflag, ...)
             goto OUT;
         }
     }
+#endif
 
-    res = f_open(&g_handle[openNum].fil, path, fmode);
+    res = f_open(fp, path, fmode);
     if (res != FR_OK) {
         PRINTK("FAT open err 0x%x!\r\n", res);
+        free(fp);
         errno = FatfsErrno(res);
         ret = FS_FAILURE;
         goto OUT;
     }
 
-    g_handle[openNum].useFlag = 1;
-    g_fileNum++;
-
-    ret = openNum;
+    file->fData = (void *)fp;
 
 OUT:
     FsUnlock();
     return ret;
 }
 
-int fatfs_close(int fd)
+int FatfsClose(struct File *file)
 {
     FRESULT res;
     INT32 ret;
+    FIL *fp = (FIL *)file->fData;
 
     ret = FsLock();
     if (ret != 0) {
@@ -628,19 +681,13 @@ int fatfs_close(int fd)
         return FS_FAILURE;
     }
 
-    if (!IsValidFd(fd)) {
-        FsUnlock();
-        errno = EBADF;
-        return FS_FAILURE;
-    }
-
-    if (g_handle[fd].fil.obj.fs == NULL) {
+    if (fp->obj.fs == NULL) {
         FsUnlock();
         errno = ENOENT;
         return FS_FAILURE;
     }
 
-    res = f_close(&g_handle[fd].fil);
+    res = f_close(fp);
     if (res != FR_OK) {
         PRINTK("FAT close err 0x%x!\r\n", res);
         FsUnlock();
@@ -649,27 +696,22 @@ int fatfs_close(int fd)
     }
 
 #if !FF_FS_TINY
-    if (g_handle[fd].fil.buf != NULL) {
-        (void)ff_memfree(g_handle[fd].fil.buf);
+    if (fp->buf != NULL) {
+        (void)ff_memfree(fp->buf);
     }
 #endif
-
-    (void)memset_s(&g_handle[fd], sizeof(FatHandleStruct), 0x0, sizeof(FatHandleStruct));
-
-    if (g_fileNum > 0) {
-        g_fileNum--;
-    }
-
+    free(file->fData);
     FsUnlock();
 
     return FS_SUCCESS;
 }
 
-ssize_t fatfs_read(int fd, void *buf, size_t nbyte)
+ssize_t FatfsRead(struct File *file, char *buf, size_t nbyte)
 {
     FRESULT res;
     INT32 ret;
     UINT32 lenRead;
+    FIL *fp = (FIL *)file->fData;
 
     if (buf == NULL) {
         errno = EFAULT;
@@ -681,20 +723,13 @@ ssize_t fatfs_read(int fd, void *buf, size_t nbyte)
         errno = ret;
         return FS_FAILURE;
     }
-
-    if (!IsValidFd(fd)) {
-        FsUnlock();
-        errno = EBADF;
-        return FS_FAILURE;
-    }
-
-    if (g_handle[fd].fil.obj.fs == NULL) {
+    if (fp == NULL) {
         FsUnlock();
         errno = ENOENT;
         return FS_FAILURE;
     }
 
-    res = f_read(&g_handle[fd].fil, buf, nbyte, &lenRead);
+    res = f_read(fp, buf, nbyte, &lenRead);
     if (res != FR_OK) {
         FsUnlock();
         errno = FatfsErrno(res);
@@ -705,12 +740,13 @@ ssize_t fatfs_read(int fd, void *buf, size_t nbyte)
     return (ssize_t)lenRead;
 }
 
-ssize_t fatfs_write(int fd, const void *buf, size_t nbyte)
+ssize_t FatfsWrite(struct File *file, const char *buf, size_t nbyte)
 {
     FRESULT res;
     INT32 ret;
     UINT32 lenWrite;
     static BOOL overFlow = FALSE;
+    FIL *fp = (FIL *)file->fData;
 
     if (buf == NULL) {
         errno = EFAULT;
@@ -723,25 +759,15 @@ ssize_t fatfs_write(int fd, const void *buf, size_t nbyte)
         return FS_FAILURE;
     }
 
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        goto ERROUT;
-    }
-
-    if (g_handle[fd].fil.obj.fs == NULL) {
+    if (fp->obj.fs == NULL) {
         errno = ENOENT;
         goto ERROUT;
     }
 
-    if (!FsCheckByID(g_handle[fd].fil.obj.fs->id)) {
-        errno = EACCES;
-        goto ERROUT;
-    }
-
-    res = f_write(&g_handle[fd].fil, buf, nbyte, &lenWrite);
+    res = f_write(fp, buf, nbyte, &lenWrite);
     if ((res == FR_OK) && (lenWrite == 0) && (nbyte != 0) && (overFlow == FALSE)) {
         overFlow = TRUE;
-        PRINTK("FAT write err 0x%x!\r\n", fd);
+        PRINTK("FAT write!\r\n");
     }
 
     if ((res != FR_OK) || (nbyte != lenWrite)) {
@@ -757,11 +783,12 @@ ERROUT:
     return FS_FAILURE;
 }
 
-off_t fatfs_lseek(int fd, off_t offset, int whence)
+off_t FatfsLseek(struct File *file, off_t offset, int whence)
 {
     FRESULT res;
     INT32 ret;
     off_t pos;
+    FIL *fp = (FIL *)file->fData;
 
     ret = FsLock();
     if (ret != 0) {
@@ -769,12 +796,7 @@ off_t fatfs_lseek(int fd, off_t offset, int whence)
         return FS_FAILURE;
     }
 
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        goto ERROUT;
-    }
-
-    if (g_handle[fd].fil.obj.fs == NULL) {
+    if (fp->obj.fs == NULL) {
         errno = ENOENT;
         goto ERROUT;
     }
@@ -782,21 +804,21 @@ off_t fatfs_lseek(int fd, off_t offset, int whence)
     if (whence == SEEK_SET) {
         pos = 0;
     } else if (whence == SEEK_CUR) {
-        pos = f_tell(&g_handle[fd].fil);
+        pos = f_tell(fp);
     } else if (whence == SEEK_END) {
-        pos = f_size(&g_handle[fd].fil);
+        pos = f_size(fp);
     } else {
         errno = EINVAL;
         goto ERROUT;
     }
 
-    res = f_lseek(&g_handle[fd].fil, offset + pos);
+    res = f_lseek(fp, offset + pos);
     if (res != FR_OK) {
         errno = FatfsErrno(res);
         goto ERROUT;
     }
 
-    pos = f_tell(&g_handle[fd].fil);
+    pos = f_tell(fp);
     FsUnlock();
     return pos;
 
@@ -806,7 +828,7 @@ ERROUT:
 }
 
 /* Remove the specified FILE */
-int fatfs_unlink(const char *path)
+int FatfsUnlink(struct MountPoint *mp, const char *path)
 {
     FRESULT res;
     INT32 ret;
@@ -822,7 +844,7 @@ int fatfs_unlink(const char *path)
         return FS_FAILURE;
     }
 
-    if (!FsCheckByPath(path)) {
+    if (!mp->mWriteEnable) {
         errno = EACCES;
         ret = FS_FAILURE;
         goto OUT;
@@ -830,7 +852,7 @@ int fatfs_unlink(const char *path)
 
     ret = FsChangeDrive(path);
     if (ret != FS_SUCCESS) {
-        PRINTK("FAT ulink ChangeDrive err 0x%x!\r\n", ret);
+        PRINTK("FAT unlink ChangeDrive err 0x%x!\r\n", ret);
         errno = ENOENT;
         ret = FS_FAILURE;
         goto OUT;
@@ -838,7 +860,7 @@ int fatfs_unlink(const char *path)
 
     res = f_unlink(path);
     if (res != FR_OK) {
-        PRINTK("FAT ulink err 0x%x!\r\n", res);
+        PRINTK("FAT unlink err 0x%x!\r\n", res);
         errno = FatfsErrno(res);
         ret = FS_FAILURE;
         goto OUT;
@@ -851,10 +873,12 @@ OUT:
     return ret;
 }
 
+#if 0
 /* Return information about a file */
-int fatfs_fstat(int fd, struct stat *buf)
+int FatfsFstat(struct File *file, struct stat *buf)
 {
     INT32 ret;
+    FIL *fp = (FIL *)file->fData;
 
     if (buf == NULL) {
         errno = EFAULT;
@@ -867,31 +891,26 @@ int fatfs_fstat(int fd, struct stat *buf)
         return FS_FAILURE;
     }
 
-    if (!IsValidFd(fd)) {
-        FsUnlock();
-        errno = EBADF;
-        return FS_FAILURE;
-    }
-
-    if (g_handle[fd].fil.obj.fs == NULL) {
+    if (fp->obj.fs == NULL) {
         FsUnlock();
         errno = ENOENT;
         return FS_FAILURE;
     }
 
-    buf->st_size = f_size(&g_handle[fd].fil);
+    buf->st_size = f_size(fp);
     buf->st_mode = S_IFREG | S_IRUSR | S_IRGRP | S_IROTH |
                    S_IWUSR | S_IWGRP | S_IWOTH |
                    S_IXUSR | S_IXGRP | S_IXOTH;
-    if (g_handle[fd].fil.obj.attr & AM_RDO) {
+    if (fp->obj.attr & AM_RDO) {
         buf->st_mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);
     }
 
     FsUnlock();
     return FS_SUCCESS;
 }
+#endif
 
-int fatfs_stat(const char *path, struct stat *buf)
+int FatfsStat(struct MountPoint *mp, const char *path, struct stat *buf)
 {
     FRESULT res;
     FILINFO fileInfo = {0};
@@ -946,10 +965,11 @@ OUT:
 }
 
 /* Synchronize all changes to Flash */
-int fatfs_fsync(int fd)
+int FatfsSync(struct File *file)
 {
     FRESULT res;
     INT32 ret;
+    FIL *fp = (FIL *)file->fData;
 
     ret = FsLock();
     if (ret != 0) {
@@ -957,25 +977,13 @@ int fatfs_fsync(int fd)
         return FS_FAILURE;
     }
 
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        ret = FS_FAILURE;
-        goto OUT;
-    }
-
-    if (g_handle[fd].fil.obj.fs == NULL) {
+    if (fp->obj.fs == NULL) {
         errno = ENOENT;
         ret = FS_FAILURE;
         goto OUT;
     }
 
-    if (!FsCheckByID(g_handle[fd].fil.obj.fs->id)) {
-        errno = EACCES;
-        ret = FS_FAILURE;
-        goto OUT;
-    }
-
-    res = f_sync(&g_handle[fd].fil);
+    res = f_sync(fp);
     if (res != FR_OK) {
         errno = FatfsErrno(res);
         ret = FS_FAILURE;
@@ -988,7 +996,7 @@ OUT:
     return ret;
 }
 
-int fatfs_mkdir(const char *path, mode_t mode)
+int FatfsMkdir(struct MountPoint *mp, const char *path)
 {
     FRESULT res;
     INT32 ret;
@@ -1004,7 +1012,7 @@ int fatfs_mkdir(const char *path, mode_t mode)
         return FS_FAILURE;
     }
 
-    if (!FsCheckByPath(path)) {
+    if (!mp->mWriteEnable) {
         errno = EACCES;
         ret = FS_FAILURE;
         goto OUT;
@@ -1032,142 +1040,134 @@ OUT:
     return ret;
 }
 
-DIR *fatfs_opendir(const char *dirName)
+int FatfsOpendir(struct Dir *dir, const char *dirName)
 {
     FRESULT res;
-    UINT32 openNum = 0;
-    UINT32 i;
     INT32 ret;
+    DIR *dp = NULL;
 
     if (dirName == NULL) {
         errno = EFAULT;
-        return NULL;
-    }
-
-    ret = FsLock();
-    if (ret != 0) {
-        errno = ret;
-        return NULL;
-    }
-
-    if (g_dirNum >= FAT_MAX_OPEN_DIRS) {
-        PRINTK("FAT opendir g_dirNum err 0x%x!\r\n", g_dirNum);
-        errno = ENFILE;
         goto ERROUT;
     }
 
-    for (i = 0; i < FAT_MAX_OPEN_DIRS; i++) {
-        if (g_dir[i].dir == NULL) {
-            openNum = i;
-            break;
-        }
+    dp = (DIR *)malloc(sizeof(DIR));
+    if (dp == NULL) {
+        errno = ENOENT;
+        goto ERROUT;
     }
 
-    if (i >= FAT_MAX_OPEN_DIRS) {
-        PRINTK("FAT dir opennum is out of range 0x%x!\r\n", openNum);
-        errno = ENFILE;
+    ret = FsLock();
+    if (ret != 0) {
+        errno = ret;
         goto ERROUT;
     }
 
     ret = FsChangeDrive(dirName);
     if (ret != FS_SUCCESS) {
         PRINTK("FAT opendir ChangeDrive err 0x%x!\r\n", ret);
-        errno = ENOENT;
+        errno = ENOENT; // TODO: why this errno is seted
         goto ERROUT;
     }
 
-    res = f_opendir(&g_dir[openNum], dirName);
+    res = f_opendir(dp, dirName);
     if (res != FR_OK) {
-        g_dir[openNum].dir = NULL;
         PRINTK("FAT opendir err 0x%x!\r\n", res);
         errno = FatfsErrno(res);
         goto ERROUT;
     }
 
-    g_dirNum++;
+    dir->dData = dp;
+    dir->dOffset = 0;
 
     FsUnlock();
-    return &g_dir[openNum];
+    return FS_SUCCESS;
 
 ERROUT:
+    if (dp != NULL) {
+        free(dp);
+    }
     FsUnlock();
-    return NULL;
+    return FS_FAILURE;
 }
 
-struct dirent *fatfs_readdir(DIR *dir)
+int FatfsReaddir(struct Dir *dir, struct dirent *dent)
 {
     FRESULT res;
     INT32 ret;
     FILINFO fileInfo = {0};
+    DIR *dp = NULL;
 
-    if (dir == NULL) {
+    if (dir == NULL || dir->dData == NULL) {
         errno = EBADF;
-        return NULL;
+        return FS_FAILURE;
     }
 
+    dp = (DIR *)dir->dData;
     ret = FsLock();
     if (ret != 0) {
         errno = ret;
-        return NULL;
+        return FS_FAILURE;
     }
 
-    res = f_readdir(dir, &fileInfo);
+    res = f_readdir(dp, &fileInfo);
     /* if res not ok or fname is NULL , return NULL */
     if ((res != FR_OK) || (fileInfo.fname[0] == 0x0)) {
         PRINTK("FAT readdir err 0x%x!\r\n", res);
         errno = FatfsErrno(res);
         FsUnlock();
-        return NULL;
+        return FS_FAILURE;
     }
 
-    (void)memcpy_s(g_retValue.d_name, sizeof(g_retValue.d_name), fileInfo.fname, sizeof(g_retValue.d_name));
+    (void)memcpy_s(dent->d_name, sizeof(dent->d_name),
+            fileInfo.fname, sizeof(dent->d_name));
     if (fileInfo.fattrib & AM_DIR) {
-        g_retValue.d_type = DT_DIR;
+        dent->d_type = DT_DIR;
     } else {
-        g_retValue.d_type = DT_REG;
+        dent->d_type = DT_REG;
     }
     FsUnlock();
 
-    return &g_retValue;
+    return FS_SUCCESS;
 }
 
-int fatfs_closedir(DIR *dir)
+int FatfsClosedir(struct Dir *dir)
 {
     FRESULT res;
     INT32 ret;
+    DIR *dp = NULL;
 
-    if (dir == NULL) {
+    if (dir == NULL || dir->dData == NULL) {
         errno = EBADF;
         return FS_FAILURE;
     }
 
+    dp = dir->dData;
     ret = FsLock();
     if (ret != 0) {
         errno = ret;
         return FS_FAILURE;
     }
 
-    g_dirNum--;
-
-    res = f_closedir(dir);
+    res = f_closedir(dp);
     if (res != FR_OK) {
         PRINTK("FAT closedir err 0x%x!\r\n", res);
         FsUnlock();
         errno = FatfsErrno(res);
         return FS_FAILURE;
     }
-    dir->dir = NULL;
+    dir->dData = NULL;
     FsUnlock();
 
     return FS_SUCCESS;
 }
 
-int fatfs_rmdir(const char *path)
+int FatfsRmdir(struct MountPoint *mp, const char *path)
 {
     FRESULT res;
     INT32 ret;
 
-    if (path == NULL) {
+    if (path == NULL || mp == NULL) {
         errno = EFAULT;
         return FS_FAILURE;
     }
@@ -1178,7 +1178,7 @@ int fatfs_rmdir(const char *path)
         return FS_FAILURE;
     }
 
-    if (!FsCheckByPath(path)) {
+    if (!mp->mWriteEnable) {
         errno = EACCES;
         ret = FS_FAILURE;
         goto OUT;
@@ -1206,7 +1206,7 @@ OUT:
     return ret;
 }
 
-int fatfs_rename(const char *oldName, const char *newName)
+int FatfsRename(struct MountPoint *mp, const char *oldName, const char *newName)
 {
     FRESULT res;
     INT32 ret;
@@ -1222,7 +1222,7 @@ int fatfs_rename(const char *oldName, const char *newName)
         return FS_FAILURE;
     }
 
-    if (!FsCheckByPath(oldName) || !FsCheckByPath(newName)) {
+    if (!mp->mWriteEnable) {
         errno = EACCES;
         ret = FS_FAILURE;
         goto OUT;
@@ -1250,7 +1250,7 @@ OUT:
     return ret;
 }
 
-int fatfs_statfs(const char *path, struct statfs *buf)
+int FatfsStatfs(const char *path, struct statfs *buf)
 {
     FATFS *fs = NULL;
     UINT32 freeClust;
@@ -1300,23 +1300,24 @@ OUT:
     return ret;
 }
 
-static int do_truncate(int fd, off_t length, UINT count)
+static int DoTruncate(struct File *file, off_t length, UINT32 count)
 {
     FRESULT res = FR_OK;
     INT32 ret = FS_SUCCESS;
     DWORD csz;
+    FIL *fp = (FIL *)file->fData;
 
-    csz = (DWORD)(g_handle[fd].fil.obj.fs)->csize * SS(g_handle[fd].fil.obj.fs); /* Cluster size */
+    csz = (DWORD)(fp->obj.fs)->csize * SS(fp->obj.fs); /* Cluster size */
     if (length > csz * count) {
 #if FF_USE_EXPAND
-        res = f_expand(&g_handle[fd].fil, 0, (FSIZE_t)(length), FALLOC_FL_KEEP_SIZE);
+        res = f_expand(fp, 0, (FSIZE_t)(length), FALLOC_FL_KEEP_SIZE);
 #else
         errno = ENOSYS;
         ret = FS_FAILURE;
         return ret;
 #endif
     } else if (length < csz * count) {
-        res = f_truncate(&g_handle[fd].fil, (FSIZE_t)length);
+        res = f_truncate(fp, (FSIZE_t)length);
     }
 
     if (res != FR_OK) {
@@ -1325,18 +1326,19 @@ static int do_truncate(int fd, off_t length, UINT count)
         return ret;
     }
 
-    g_handle[fd].fil.obj.objsize = length; /* Set file size to length */
-    g_handle[fd].fil.flag |= 0x40; /* Set modified flag */
+    fp->obj.objsize = length; /* Set file size to length */
+    fp->flag |= 0x40; /* Set modified flag */
 
     return ret;
 }
 
-int fatfs_ftruncate(int fd, off_t length)
+int FatfsTruncate(struct File *file, off_t length)
 {
     FRESULT res;
     INT32 ret;
     UINT count;
     DWORD fclust;
+    FIL *fp = (FIL *)file->fData;
 
     if ((length < 0) || (length > UINT_MAX)) {
         errno = EINVAL;
@@ -1349,32 +1351,20 @@ int fatfs_ftruncate(int fd, off_t length)
         return FS_FAILURE;
     }
 
-    if (!IsValidFd(fd)) {
-        errno = EBADF;
-        ret = FS_FAILURE;
-        goto OUT;
-    }
-
-    if (g_handle[fd].fil.obj.fs == NULL) {
+    if (fp->obj.fs == NULL) {
         errno = ENOENT;
         ret = FS_FAILURE;
         goto OUT;
     }
 
-    if (!FsCheckByID(g_handle[fd].fil.obj.fs->id)) {
-        errno = EACCES;
-        ret = FS_FAILURE;
-        goto OUT;
-    }
-
-    res = f_getclustinfo(&g_handle[fd].fil, &fclust, &count);
+    res = f_getclustinfo(fp, &fclust, &count);
     if (res != FR_OK) {
         errno = FatfsErrno(res);
         ret = FS_FAILURE;
         goto OUT;
     }
 
-    ret = do_truncate(fd, length, count);
+    ret = DoTruncate(file, length, count);
     if (ret != FR_OK) {
         goto OUT;
     }
@@ -1386,15 +1376,21 @@ OUT:
     return ret;
 }
 
-int fatfs_fdisk(int pdrv, const unsigned int *partTbl)
+int FatfsFdisk(const char *dev, int *lengthArray, int arrayNum)
 {
+    int pdrv = 0;
+    int sum = 0;
+    int partTbl[4] = { 0 };
     INT32 index;
     FRESULT res;
     INT32 ret;
 
-    if (partTbl == NULL) {
-        errno = EFAULT;
-        return FS_FAILURE;
+    for (int i = 0; i < arrayNum; i++) {
+        sum += lengthArray[i];
+    }
+
+    for (int i = 0; i < arrayNum; i++) {
+        partTbl[i] = lengthArray[i] / sum;
     }
 
     ret = FsLock();
@@ -1427,13 +1423,20 @@ OUT:
     return ret;
 }
 
-int fatfs_format(const char *dev, int sectors, int option)
+int FatfsFormat(const char *partName, void *privData)
 {
-    INT32 index;
     FRESULT res;
     INT32 ret;
     MKFS_PARM opt = {0};
+    int option = *(int *)privData;
+    char *dev = NULL; /* logical driver */
 
+    if (partName == NULL) {
+        errno = EFAULT;
+        return FS_FAILURE;
+    }
+
+    dev = GetLdPath(partName);
     if (dev == NULL) {
         errno = EFAULT;
         return FS_FAILURE;
@@ -1445,22 +1448,25 @@ int fatfs_format(const char *dev, int sectors, int option)
         return FS_FAILURE;
     }
 
-    index = FsPartitionMatch(dev, VOLUME_NAME);
-    if (index == FS_FAILURE) {
-        errno = ENOENT;
-        ret = FS_FAILURE;
-        goto OUT;
-    }
+    /* check if dev is mounted by iterate the mp list
+       format is not allowed when the device has been mounted. */
+    struct MountPoint *iter = NULL;
+    LOS_MP_FOR_EACH_ENTRY(iter) {
+        if (strcmp(iter->mFs->fsType, FSTYPE_FATFS) != 0) {
+            continue;
+        }
 
-    /* format is not allowed when the device has been mounted. */
-    if (g_fatfs[index].fs_type != 0) {
-        errno = EBUSY;
-        ret = FS_FAILURE;
-        goto OUT;
+        FATFS *f = (FATFS *)iter->mData;
+        if (f->fs_type != 0) {
+            errno = EBUSY;
+            ret = FS_FAILURE;
+            goto OUT;
+        }
     }
 
-    opt.fmt = option,
-    opt.n_sect = sectors,
+    opt.fmt = option;
+    opt.n_sect = 0; /* TODO: use default allocation unit size depends on the 
+                       volume size. */
     res = f_mkfs(dev, &opt, g_workBuffer, FF_MAX_SS);
     if (res != FR_OK) {
         errno = FatfsErrno(res);
@@ -1476,26 +1482,42 @@ OUT:
 }
 
 struct MountOps g_fatfsMnt = {
-    .Mount = fatfs_mount,
-    .Umount = fatfs_umount,
-    .Umount2 = fatfs_umount2,
-    .Statfs = fatfs_statfs,
+    .mount = FatfsMount,
+    .umount = FatfsUmount,
+    .umount2 = FatfsUmount2,
+    .statfs = FatfsStatfs,
 };
 
 struct FileOps g_fatfsFops = {
-    .Mkdir = fatfs_mkdir,
-    .Unlink = fatfs_unlink,
-    .Rmdir = fatfs_rmdir,
-    .Opendir = fatfs_opendir,
-    .Readdir = fatfs_readdir,
-    .Closedir = fatfs_closedir,
-    .Open = fatfs_open,
-    .Close = fatfs_close,
-    .Write = fatfs_write,
-    .Read = fatfs_read,
-    .Seek = fatfs_lseek,
-    .Rename = fatfs_rename,
-    .Getattr = fatfs_stat,
-    .Fsync = fatfs_fsync,
-    .Fstat = fatfs_fstat,
+    .open = FatfsOpen,
+    .close = FatfsClose,
+    .read = FatfsRead,
+    .write = FatfsWrite,
+    .lseek = FatfsLseek,
+    .lseek64 = NULL,
+    .stat = FatfsStat,
+    .truncate = FatfsTruncate,
+    .unlink = FatfsUnlink,
+    .rename = FatfsRename,
+    .ioctl = NULL, /* not support */
+    .sync = FatfsSync,
+//    .rmdir = FatfsRmdir,
+    .opendir = FatfsOpendir,
+    .readdir = FatfsReaddir,
+    .closedir = FatfsClosedir,
+//    .getattr = FatfsStat,
+    .mkdir = FatfsMkdir,
+    .rmdir = FatfsRmdir,
 };
+
+struct FsMgt g_fatfsMgt = {
+    .fdisk = FatfsFdisk,
+    .format = FatfsFormat,
+};
+
+extern int LOS_FsRegister(const char *fsType, struct MountOps *fsMops, struct FileOps *fsFops, struct FsMgt *fsMgt);
+
+void FatFsInit(void)
+{
+    (void)LOS_FsRegister(FSTYPE_FATFS, &g_fatfsMnt, &g_fatfsFops, &g_fatfsMgt);
+}
diff --git a/components/fs/fatfs/fatfs.h b/components/fs/fatfs/fatfs.h
index 21ad1e7..20ef48b 100644
--- a/components/fs/fatfs/fatfs.h
+++ b/components/fs/fatfs/fatfs.h
@@ -38,17 +38,12 @@
 #include "sys/mount.h"
 #include "sys/stat.h"
 #include "sys/statfs.h"
-#include "fs_config.h"
 #ifdef __cplusplus
 #if __cplusplus
 extern "C" {
 #endif /* __cplusplus */
 #endif /* __cplusplus */
 
-#ifndef FAT_MAX_OPEN_FILES
-#define FAT_MAX_OPEN_FILES    50
-#endif /* FAT_MAX_OPEN_FILES */
-
 /* Format options */
 #define FMT_FAT      0x01
 #define FMT_FAT32    0x02
@@ -105,6 +100,8 @@ int fatfs_fdisk(int pdrv, const unsigned int *partTbl);
   */
 int fatfs_format(const char *dev, int sectors, int option);
 
+void FatFsInit();
+
 #ifdef __cplusplus
 #if __cplusplus
 }
diff --git a/components/fs/fs.c b/components/fs/fs.c
deleted file mode 100644
index b28f2ee..0000000
--- a/components/fs/fs.c
+++ /dev/null
@@ -1,549 +0,0 @@
-/*
- * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
- * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of
- *    conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list
- *    of conditions and the following disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used
- *    to endorse or promote products derived from this software without specific prior written
- *    permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
- * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-#include "fs_operations.h"
-#include "los_config.h"
-#if (LOSCFG_SUPPORT_FATFS == 1)
-#include "fatfs.h"
-#endif
-#include "dirent.h"
-#include "errno.h"
-#include "fcntl.h"
-#include "securec.h"
-#include "stdio.h"
-#include "stdlib.h"
-#include "string.h"
-#include "sys/mount.h"
-#include "sys/statfs.h"
-#include "sys/stat.h"
-#include "unistd.h"
-
-#ifdef LOSCFG_NET_LWIP_SACK
-#define _BSD_SOURCE
-#include "lwip/sockets.h"
-#endif
-
-#include "vfs_config.h"
-
-#ifdef LOSCFG_RANDOM_DEV
-#include "hks_client.h"
-#define RANDOM_DEV_FD  CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS
-#define RANDOM_DEV_PATH  "/dev/random"
-#endif
-
-#define FREE_AND_SET_NULL(ptr) do { \
-    free(ptr);                      \
-    ptr = NULL;                     \
-} while (0)
-
-#ifdef LOSCFG_RANDOM_DEV
-/**
- * @brief Get canonical form of a given path based on cwd(Current working directory).
- *
- * @param cwd Indicates the current working directory.
- * @param path Indicates the path to be canonicalization.
- * @param buf Indicates the pointer to the buffer where the result will be return.
- * @param bufSize Indicates the size of the buffer.
- * @return Returns the length of the canonical path.
- *
- * @attention if path is an absolute path, cwd is ignored. if cwd if not specified, it is assumed to be root('/').
- *            if the buffer is not big enough the result will be truncated, but the return value will always be the
- *            length of the canonical path.
- */
-static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, size_t bufSize)
-{
-    size_t offset;
-    if (!path) {
-        path = "";
-    }
-
-    if (!cwd || path[0] == '/') {
-        cwd = "";
-    }
-
-    offset = strlen("///") + 1; // three '/' and one '\0'
-    size_t tmpLen = strlen(cwd) + strlen(path) + offset;
-    char *tmpBuf = (char *)malloc(tmpLen);
-    if (tmpBuf == NULL) {
-        return FS_SUCCESS;
-    }
-
-    if (-1 == sprintf_s(tmpBuf, tmpLen, "/%s/%s/", cwd, path)) {
-        free(tmpBuf);
-        return FS_SUCCESS;
-    }
-
-    char *p;
-    /* replace /./ to / */
-    offset = strlen("/./") - 1;
-    while ((p = strstr(tmpBuf, "/./")) != NULL) {
-        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
-            free(tmpBuf);
-            return FS_SUCCESS;
-        }
-    }
-
-    /* replace // to / */
-    while ((p = strstr(tmpBuf, "//")) != NULL) {
-        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + 1, tmpLen - (p - tmpBuf) - 1)) {
-            free(tmpBuf);
-            return FS_SUCCESS;
-        }
-    }
-
-    /* handle /../ (e.g., replace /aa/bb/../ to /aa/) */
-    offset = strlen("/../") - 1;
-    while ((p = strstr(tmpBuf, "/../")) != NULL) {
-        char *start = p;
-        while (start > tmpBuf && *(start - 1) != '/') {
-            --start;
-        }
-        if (EOK != memmove_s(start, tmpLen - (start - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
-            free(tmpBuf);
-            return FS_SUCCESS;
-        }
-    }
-
-    size_t totalLen = strlen(tmpBuf);
-    /* strip the last / */
-    if (totalLen > 1 && tmpBuf[totalLen - 1] == '/') {
-        tmpBuf[--totalLen] = 0;
-    }
-
-    if (!buf || bufSize == 0) {
-        free(tmpBuf);
-        return totalLen;
-    }
-
-    if (EOK != memcpy_s(buf, bufSize, tmpBuf, (((totalLen + 1) > bufSize) ? bufSize : (totalLen + 1)))) {
-        free(tmpBuf);
-        return FS_SUCCESS;
-    }
-
-    buf[bufSize - 1] = 0;
-    free(tmpBuf);
-    return totalLen;
-}
-#endif
-
-static struct FsMap g_fsmap[MAX_FILESYSTEM_LEN] = {0};
-static struct FsMap *g_fs = NULL;
-
-static void InitMountInfo(void)
-{
-#if (LOSCFG_SUPPORT_FATFS == 1)
-    extern struct MountOps g_fatfsMnt;
-    extern struct FileOps g_fatfsFops;
-    g_fsmap[0].fileSystemtype = strdup("fat");
-    g_fsmap[0].fsMops = &g_fatfsMnt;
-    g_fsmap[0].fsFops = &g_fatfsFops;
-#endif
-#if (LOSCFG_SUPPORT_LITTLEFS == 1)
-    extern struct MountOps g_lfsMnt;
-    extern struct FileOps g_lfsFops;
-    g_fsmap[1].fileSystemtype = strdup("littlefs");
-    g_fsmap[1].fsMops = &g_lfsMnt;
-    g_fsmap[1].fsFops = &g_lfsFops;
-#endif
-}
-
-static struct FsMap *MountFindfs(const char *fileSystemtype)
-{
-    struct FsMap *m = NULL;
-
-    for (int i = 0; i < MAX_FILESYSTEM_LEN; i++) {
-        m = &(g_fsmap[i]);
-        if (m->fileSystemtype && strcmp(fileSystemtype, m->fileSystemtype) == 0) {
-            return m;
-        }
-    }
-
-    return NULL;
-}
-
-int mount(const char *source, const char *target,
-          const char *filesystemtype, unsigned long mountflags,
-          const void *data)
-{
-    static int initFlag = 0;
-
-    if (initFlag == 0) {
-        InitMountInfo();
-        initFlag = 1;
-    }
-
-    g_fs = MountFindfs(filesystemtype);
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-
-    if (g_fs->fsMops == NULL || g_fs->fsMops->Mount == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-
-    return g_fs->fsMops->Mount(source, target, filesystemtype, mountflags, data);
-}
-
-int umount(const char *target)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsMops == NULL || g_fs->fsMops->Umount == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsMops->Umount(target);
-}
-
-int umount2(const char *target, int flag)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsMops == NULL || g_fs->fsMops->Umount2 == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsMops->Umount2(target, flag);
-}
-
-int open(const char *path, int oflag, ...)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    unsigned flags = O_RDONLY | O_WRONLY | O_RDWR | O_APPEND | O_CREAT | O_LARGEFILE | O_TRUNC | O_EXCL | O_DIRECTORY;
-    if ((unsigned)oflag & ~flags) {
-        errno = EINVAL;
-        return FS_FAILURE;
-    }
-
-    size_t pathLen = strlen(path) + 1;
-    char *canonicalPath = (char *)malloc(pathLen);
-    if (!canonicalPath) {
-        errno = ENOMEM;
-        return FS_FAILURE;
-    }
-    if (GetCanonicalPath(NULL, path, canonicalPath, pathLen) == 0) {
-        FREE_AND_SET_NULL(canonicalPath);
-        errno = ENOMEM;
-        return FS_FAILURE;
-    }
-
-    if (strcmp(canonicalPath, RANDOM_DEV_PATH) == 0) {
-        FREE_AND_SET_NULL(canonicalPath);
-        if ((O_ACCMODE & (unsigned)oflag) != O_RDONLY) {
-            errno = EPERM;
-            return FS_FAILURE;
-        }
-        if ((unsigned)oflag & O_DIRECTORY) {
-            errno = ENOTDIR;
-            return FS_FAILURE;
-        }
-        return RANDOM_DEV_FD;
-    }
-    if (strcmp(canonicalPath, "/") == 0 || strcmp(canonicalPath, "/dev") == 0) {
-        FREE_AND_SET_NULL(canonicalPath);
-        if ((unsigned)oflag & O_DIRECTORY) {
-            errno = EPERM;
-            return FS_FAILURE;
-        }
-        errno = EISDIR;
-        return FS_FAILURE;
-    }
-    FREE_AND_SET_NULL(canonicalPath);
-#endif
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Open == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Open(path, oflag);
-}
-
-int close(int fd)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    if (fd == RANDOM_DEV_FD) {
-        return FS_SUCCESS;
-    }
-#endif
-#ifdef LOSCFG_NET_LWIP_SACK
-    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
-        return closesocket(fd);
-    }
-#endif
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Close == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Close(fd);
-}
-
-ssize_t read(int fd, void *buf, size_t nbyte)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    if (fd == RANDOM_DEV_FD) {
-        if (nbyte == 0) {
-            return FS_SUCCESS;
-        }
-        if (buf == NULL) {
-            errno = EINVAL;
-            return FS_FAILURE;
-        }
-        if (nbyte > 1024) { /* 1024, max random_size */
-            nbyte = 1024; /* hks_generate_random: random_size must <= 1024 */
-        }
-        struct hks_blob key = {HKS_BLOB_TYPE_RAW, (uint8_t *)buf, nbyte};
-        if (hks_generate_random(&key) != 0) {
-            errno = EIO;
-            return FS_FAILURE;
-        }
-        return (ssize_t)nbyte;
-    }
-#endif
-#ifdef LOSCFG_NET_LWIP_SACK
-    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
-        return recv(fd, buf, nbyte, 0);
-    }
-#endif
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Read == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Read(fd, buf, nbyte);
-}
-
-ssize_t write(int fd, const void *buf, size_t nbyte)
-{
-#ifdef LOSCFG_RANDOM_DEV
-    if (fd == RANDOM_DEV_FD) {
-        errno = EBADF; /* "/dev/random" is readonly */
-        return FS_FAILURE;
-    }
-#endif
-#ifdef LOSCFG_NET_LWIP_SACK
-    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
-        return send(fd, buf, nbyte, 0);
-    }
-#endif
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Write == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Write(fd, buf, nbyte);
-}
-
-off_t lseek(int fd, off_t offset, int whence)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Seek == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Seek(fd, offset, whence);
-}
-
-int unlink(const char *path)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Unlink == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Unlink(path);
-}
-
-int fstat(int fd, struct stat *buf)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Fstat == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Fstat(fd, buf);
-}
-
-int stat(const char *path, struct stat *buf)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Getattr == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Getattr(path, buf);
-}
-
-int fsync(int fd)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Fsync == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Fsync(fd);
-}
-
-int mkdir(const char *path, mode_t mode)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Mkdir == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Mkdir(path, mode);
-}
-
-DIR *opendir(const char *dirName)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return NULL;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Opendir == NULL) {
-        errno = ENOSYS;
-        return NULL;
-    }
-    return g_fs->fsFops->Opendir(dirName);
-}
-
-struct dirent *readdir(DIR *dir)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return NULL;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Readdir == NULL) {
-        errno = ENOSYS;
-        return NULL;
-    }
-    return g_fs->fsFops->Readdir(dir);
-}
-
-int closedir(DIR *dir)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Closedir == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Closedir(dir);
-}
-
-int rmdir(const char *path)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Rmdir == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Rmdir(path);
-}
-
-int rename(const char *oldName, const char *newName)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Rename == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Rename(oldName, newName);
-}
-
-int statfs(const char *path, struct statfs *buf)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsMops == NULL || g_fs->fsMops->Statfs == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsMops->Statfs(path, buf);
-}
-
-int ftruncate(int fd, off_t length)
-{
-    if (g_fs == NULL) {
-        errno = ENODEV;
-        return FS_FAILURE;
-    }
-    if (g_fs->fsFops == NULL || g_fs->fsFops->Ftruncate == NULL) {
-        errno = ENOSYS;
-        return FS_FAILURE;
-    }
-    return g_fs->fsFops->Ftruncate(fd, length);
-}
diff --git a/components/fs/littlefs/Kconfig b/components/fs/littlefs/Kconfig
new file mode 100644
index 0000000..3707eed
--- /dev/null
+++ b/components/fs/littlefs/Kconfig
@@ -0,0 +1,51 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+config FS_LITTLEFS
+    bool "Enable Little FS"
+    default n
+    depends on FS_VFS
+    help
+      Answer Y to enable LiteOS support Little FS filesystem.
+
+if FS_LITTLEFS
+
+config LITTLE_FS_MAX_OPEN_FILES
+    int "Maximum number of opened files"
+    default 100
+    help
+        This is a global maximum across all mounted littlefs filesystems.
+
+config LFS_MAX_MOUNT_SIZE
+    int "Maximum number of mount points"
+    default 3
+    help
+        This is a global maximum number of mount points.
+
+endif # FS_LITTLEFS
diff --git a/components/fs/littlefs/lfs_api.c b/components/fs/littlefs/lfs_api.c
index 043ffc0..a079831 100644
--- a/components/fs/littlefs/lfs_api.c
+++ b/components/fs/littlefs/lfs_api.c
@@ -32,75 +32,16 @@
 #define _GNU_SOURCE 1
 #include "lfs_api.h"
 #include "los_config.h"
+#include "fs_files.h"
+#include "fs_operations.h"
+#include "partition.h"
 #include "securec.h"
 
-lfs_t g_lfs;
-FileDirInfo g_lfsDir[LFS_MAX_OPEN_DIRS] = {0};
-
-struct FileOpInfo g_fsOp[LOSCFG_LFS_MAX_MOUNT_SIZE] = {0};
-static LittleFsHandleStruct g_handle[LITTLE_FS_MAX_OPEN_FILES] = {0};
 struct dirent g_nameValue;
 static pthread_mutex_t g_FslocalMutex = PTHREAD_MUTEX_INITIALIZER;
 static const char *g_littlefsMntName[LOSCFG_LFS_MAX_MOUNT_SIZE] = {"/a", "/b", "/c"};
 
-LittleFsHandleStruct *LfsAllocFd(const char *fileName, int *fd)
-{
-    pthread_mutex_lock(&g_FslocalMutex);
-    for (int i = 0; i < LITTLE_FS_MAX_OPEN_FILES; i++) {
-        if (g_handle[i].useFlag == 0) {
-            *fd = i;
-            g_handle[i].useFlag = 1;
-            g_handle[i].pathName = strdup(fileName);
-            pthread_mutex_unlock(&g_FslocalMutex);
-            return &(g_handle[i]);
-        }
-    }
-    pthread_mutex_unlock(&g_FslocalMutex);
-    *fd = INVALID_FD;
-    return NULL;
-}
-
-static void LfsFreeFd(int fd)
-{
-    pthread_mutex_lock(&g_FslocalMutex);
-    g_handle[fd].useFlag = 0;
-    if (g_handle[fd].pathName != NULL) {
-        free((void *)g_handle[fd].pathName);
-        g_handle[fd].pathName = NULL;
-    }
-
-    if (g_handle[fd].lfsHandle != NULL) {
-        g_handle[fd].lfsHandle = NULL;
-    }
-    pthread_mutex_unlock(&g_FslocalMutex);
-}
-
-BOOL CheckFileIsOpen(const char *fileName)
-{
-    pthread_mutex_lock(&g_FslocalMutex);
-    for (int i = 0; i < LITTLE_FS_MAX_OPEN_FILES; i++) {
-        if (g_handle[i].useFlag == 1) {
-            if (strcmp(g_handle[i].pathName, fileName) == 0) {
-                pthread_mutex_unlock(&g_FslocalMutex);
-                return TRUE;
-            }
-        }
-    }
-    pthread_mutex_unlock(&g_FslocalMutex);
-    return FALSE;
-}
-
-static BOOL LfsFdIsValid(int fd)
-{
-    if (fd >= LITTLE_FS_MAX_OPEN_FILES || fd < 0) {
-        return FALSE;
-    }
-    if (g_handle[fd].lfsHandle == NULL) {
-        return FALSE;
-    }
-    return TRUE;
-}
-
+#if 0
 FileDirInfo *GetFreeDir(const char *dirName)
 {
     pthread_mutex_lock(&g_FslocalMutex);
@@ -146,6 +87,7 @@ BOOL CheckDirIsOpen(const char *dirName)
     pthread_mutex_unlock(&g_FslocalMutex);
     return FALSE;
 }
+#endif
 
 int GetFirstLevelPathLen(const char *pathName)
 {
@@ -160,29 +102,10 @@ int GetFirstLevelPathLen(const char *pathName)
     return len;
 }
 
-BOOL CheckPathIsMounted(const char *pathName, struct FileOpInfo **fileOpInfo)
-{
-    char tmpName[LITTLEFS_MAX_LFN_LEN] = {0};
-    int len = GetFirstLevelPathLen(pathName);
-
-    pthread_mutex_lock(&g_FslocalMutex);
-    for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
-        if (g_fsOp[i].useFlag == 1) {
-            (void)strncpy_s(tmpName, LITTLEFS_MAX_LFN_LEN, pathName, len);
-            if (strcmp(tmpName, g_fsOp[i].dirName) == 0) {
-                *fileOpInfo = &(g_fsOp[i]);
-                pthread_mutex_unlock(&g_FslocalMutex);
-                return TRUE;
-            }
-        }
-    }
-    pthread_mutex_unlock(&g_FslocalMutex);
-    return FALSE;
-}
-
-struct FileOpInfo *AllocMountRes(const char* target, const struct FileOps *fileOps)
+lfs_t *AllocMountRes()
 {
     pthread_mutex_lock(&g_FslocalMutex);
+#if 0
     for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
         if (g_fsOp[i].useFlag == 0 && strcmp(target, g_littlefsMntName[i]) == 0) {
             g_fsOp[i].useFlag = 1;
@@ -192,9 +115,11 @@ struct FileOpInfo *AllocMountRes(const char* target, const struct FileOps *fileO
             return &(g_fsOp[i]);
         }
     }
+#endif
+    lfs_t *res = (lfs_t *)malloc(sizeof(lfs_t));
 
     pthread_mutex_unlock(&g_FslocalMutex);
-    return NULL;
+    return res;
 }
 
 int SetDefaultMountPath(int pathNameIndex, const char* target)
@@ -209,59 +134,6 @@ int SetDefaultMountPath(int pathNameIndex, const char* target)
     return VFS_OK;
 }
 
-struct FileOpInfo *GetMountRes(const char *target, int *mountIndex)
-{
-    pthread_mutex_lock(&g_FslocalMutex);
-    for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
-        if (g_fsOp[i].useFlag == 1) {
-            if (g_fsOp[i].dirName && strcmp(target, g_fsOp[i].dirName) == 0) {
-                *mountIndex = i;
-                pthread_mutex_unlock(&g_FslocalMutex);
-                return &(g_fsOp[i]);
-            }
-        }
-    }
-
-    pthread_mutex_unlock(&g_FslocalMutex);
-    return NULL;
-}
-
-int FreeMountResByIndex(int mountIndex)
-{
-    if (mountIndex < 0 || mountIndex >= LOSCFG_LFS_MAX_MOUNT_SIZE) {
-        return VFS_ERROR;
-    }
-
-    pthread_mutex_lock(&g_FslocalMutex);
-    if (g_fsOp[mountIndex].useFlag == 1 && g_fsOp[mountIndex].dirName != NULL) {
-        g_fsOp[mountIndex].useFlag = 0;
-        free(g_fsOp[mountIndex].dirName);
-        g_fsOp[mountIndex].dirName = NULL;
-    }
-    pthread_mutex_unlock(&g_FslocalMutex);
-
-    return VFS_OK;
-}
-
-int FreeMountRes(const char *target)
-{
-    pthread_mutex_lock(&g_FslocalMutex);
-    for (int i = 0; i < LOSCFG_LFS_MAX_MOUNT_SIZE; i++) {
-        if (g_fsOp[i].useFlag == 1) {
-            if (g_fsOp[i].dirName && strcmp(target, g_fsOp[i].dirName) == 0) {
-                g_fsOp[i].useFlag = 0;
-                free(g_fsOp[i].dirName);
-                g_fsOp[i].dirName = NULL;
-                pthread_mutex_unlock(&g_FslocalMutex);
-                return VFS_OK;
-            }
-        }
-    }
-
-    pthread_mutex_unlock(&g_FslocalMutex);
-    return VFS_ERROR;
-}
-
 static int ConvertFlagToLfsOpenFlag (int oflags)
 {
     int lfsOpenFlag = 0;
@@ -302,70 +174,37 @@ static int LittlefsErrno(int result)
     return (result < 0) ? -result : result;
 }
 
-const struct MountOps g_lfsMnt = {
-    .Mount = LfsMount,
-    .Umount = LfsUmount,
-};
-
-const struct FileOps g_lfsFops = {
-    .Mkdir = LfsMkdir,
-    .Unlink = LfsUnlink,
-    .Rmdir = LfsRmdir,
-    .Opendir = LfsOpendir,
-    .Readdir = LfsReaddir,
-    .Closedir = LfsClosedir,
-    .Open = LfsOpen,
-    .Close = LfsClose,
-    .Write = LfsWrite,
-    .Read = LfsRead,
-    .Seek = LfsSeek,
-    .Rename = LfsRename,
-    .Getattr = LfsStat,
-    .Fsync = LfsFsync,
-    .Fstat = LfsFstat,
-};
-
-int LfsMount(const char *source, const char *target, const char *fileSystemType, unsigned long mountflags,
-    const void *data)
+int LfsMount(struct MountPoint *mp, const char *source,
+             unsigned long mountflags, const void *data)
 {
     int ret;
-    struct FileOpInfo *fileOpInfo = NULL;
+    lfs_t *mountHdl = NULL;
 
-    if (target == NULL || fileSystemType == NULL || data == NULL) {
+    if (mp == NULL || mp->mPath == NULL || data == NULL) {
         errno = EFAULT;
         ret = VFS_ERROR;
         goto errout;
     }
 
-    if (strcmp(fileSystemType, "littlefs") != 0) {
+    mountHdl = (lfs_t *)malloc(sizeof(lfs_t));
+    if (mountHdl == NULL) {
         errno = ENODEV;
         ret = VFS_ERROR;
         goto errout;
     }
+    (void)memset_s(mountHdl, sizeof(lfs_t), 0, sizeof(lfs_t));
+    mp->mData = (void *)mountHdl;
 
-    if (CheckPathIsMounted(target, &fileOpInfo)) {
-        errno = EBUSY;
-        ret = VFS_ERROR;
-        goto errout;
-    }
-
-    // select free mount resource
-    fileOpInfo = AllocMountRes(target, &g_lfsFops);
-    if (fileOpInfo == NULL) {
-        errno = ENODEV;
-        ret = VFS_ERROR;
-        goto errout;
-    }
-
-    ret = lfs_mount(&(fileOpInfo->lfsInfo), (struct lfs_config*)data);
+    ret = lfs_mount((lfs_t *)mp->mData, (struct lfs_config *)data);
     if (ret != 0) {
-        ret = lfs_format(&(fileOpInfo->lfsInfo), (struct lfs_config*)data);
+        ret = lfs_format((lfs_t *)mp->mData, (struct lfs_config*)data);
         if (ret == 0) {
-            ret = lfs_mount(&(fileOpInfo->lfsInfo), (struct lfs_config*)data);
+            ret = lfs_mount((lfs_t *)mp->mData, (struct lfs_config*)data);
         }
     }
 
     if (ret != 0) {
+        free(mountHdl);
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
     }
@@ -374,49 +213,40 @@ errout:
     return ret;
 }
 
-int LfsUmount(const char *target)
+int LfsUmount(struct MountPoint *mp, const char* target)
 {
     int ret;
-    int mountIndex = -1;
-    struct FileOpInfo *fileOpInfo = NULL;
 
-    if (target == NULL) {
+    if ((mp == NULL) || (target == NULL)) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    fileOpInfo = GetMountRes(target, &mountIndex);
-    if (fileOpInfo == NULL) {
-        errno = ENOENT;
-        return VFS_ERROR;
-    }
-
-    ret = lfs_unmount(&(fileOpInfo->lfsInfo));
+    ret = lfs_unmount((lfs_t *)mp->mData);
     if (ret != 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
     }
 
-    (void)FreeMountResByIndex(mountIndex);
+    free(mp->mData);
     return ret;
 }
 
-int LfsUnlink(const char *fileName)
+int LfsUnlink(struct MountPoint *mp, const char *fileName)
 {
     int ret;
-    struct FileOpInfo *fileOpInfo = NULL;
 
-    if (fileName == NULL) {
+    if (mp == NULL || fileName == NULL) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    if (CheckPathIsMounted(fileName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+    if (mp->mData == NULL) {
         errno = ENOENT;
         return VFS_ERROR;
     }
 
-    ret = lfs_remove(&(fileOpInfo->lfsInfo), fileName);
+    ret = lfs_remove((lfs_t *)mp->mData, fileName);
     if (ret != 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -425,22 +255,18 @@ int LfsUnlink(const char *fileName)
     return ret;
 }
 
-int LfsMkdir(const char *dirName, mode_t mode)
+int LfsMkdir(struct MountPoint *mp, const char *dirName)
 {
     int ret;
-    struct FileOpInfo *fileOpInfo = NULL;
 
-    if (dirName == NULL) {
+    if (dirName == NULL || mp == NULL || mp->mData == NULL) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
-        errno = ENOENT;
-        return VFS_ERROR;
-    }
+    lfs_t *lfs = (lfs_t *)mp->mData;
 
-    ret = lfs_mkdir(&(fileOpInfo->lfsInfo), dirName);
+    ret = lfs_mkdir(lfs, dirName);
     if (ret != 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -449,23 +275,18 @@ int LfsMkdir(const char *dirName, mode_t mode)
     return ret;
 }
 
-int LfsRmdir(const char *dirName)
+int LfsRmdir(struct MountPoint *mp, const char *dirName)
 {
     int ret;
 
-    struct FileOpInfo *fileOpInfo = NULL;
+    lfs_t *lfs = (lfs_t *)mp->mData;
 
     if (dirName == NULL) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
-        errno = ENOENT;
-        return VFS_ERROR;
-    }
-
-    ret = lfs_remove(&(fileOpInfo->lfsInfo), dirName);
+    ret = lfs_remove(lfs, dirName);
     if (ret != 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -474,96 +295,99 @@ int LfsRmdir(const char *dirName)
     return ret;
 }
 
-DIR *LfsOpendir(const char *dirName)
+int LfsOpendir(struct Dir *dir, const char *dirName)
 {
     int ret;
-    struct FileOpInfo *fileOpInfo = NULL;
 
-    if (dirName == NULL) {
+    if (dir == NULL || dir->dMp == NULL || dir->dMp->mData == NULL) {
         errno = EFAULT;
-        goto errout;
-    }
-
-    if (CheckPathIsMounted(dirName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
-        errno = ENOENT;
-        goto errout;
-    }
-
-    if (CheckDirIsOpen(dirName)) {
-        errno = EBUSY;
-        goto errout;
+        return VFS_ERROR;
     }
 
-    FileDirInfo *dirInfo = GetFreeDir(dirName);
+    lfs_t *lfs = (lfs_t *)dir->dMp->mData;
+    lfs_dir_t *dirInfo = (lfs_dir_t *)malloc(sizeof(lfs_dir_t));
     if (dirInfo == NULL) {
-        errno = ENFILE;
-        goto errout;
+        errno = ENOMEM;
+        return VFS_ERROR;
     }
 
-    ret = lfs_dir_open(&(fileOpInfo->lfsInfo), (lfs_dir_t *)(&(dirInfo->dir)), dirName);
-
+    (void)memset_s(dirInfo, sizeof(lfs_dir_t), 0, sizeof(lfs_dir_t));
+    ret = lfs_dir_open(lfs, dirInfo, dirName);
     if (ret != 0) {
-        FreeDirInfo(dirName);
+        free(dirInfo);
         errno = LittlefsErrno(ret);
         goto errout;
     }
 
-    dirInfo->lfsHandle = &(fileOpInfo->lfsInfo);
+    dir->dData = dirInfo;
+    dir->dOffset = 0;
 
-    return (DIR *)dirInfo;
+    return VFS_OK;
 
 errout:
-    return NULL;
+    return VFS_ERROR;
 }
 
-struct dirent *LfsReaddir(DIR *dir)
+int LfsReaddir(struct Dir *dir, struct dirent *dent)
 {
     int ret;
     struct lfs_info lfsInfo;
 
-    FileDirInfo *dirInfo = (FileDirInfo *)dir;
+    if (dir == NULL || dir->dMp == NULL || dir->dMp->mData == NULL ||
+        dent == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
 
-    if (dirInfo == NULL || dirInfo->lfsHandle == NULL) {
+    if (dir->dData == NULL) {
         errno = EBADF;
-        return NULL;
+        return VFS_ERROR;
     }
 
-    ret = lfs_dir_read(dirInfo->lfsHandle, (lfs_dir_t *)(&(dirInfo->dir)), &lfsInfo);
+    lfs_t *lfs = (lfs_t *)dir->dMp->mData;
+    lfs_dir_t *dirInfo = (lfs_dir_t *)dir->dData;
+
+    ret = lfs_dir_read(lfs, dirInfo, &lfsInfo);
     if (ret == TRUE) {
         pthread_mutex_lock(&g_FslocalMutex);
-        (void)strncpy_s(g_nameValue.d_name, sizeof(g_nameValue.d_name), lfsInfo.name, strlen(lfsInfo.name) + 1);
+        (void)strncpy_s(dent->d_name, sizeof(dent->d_name), lfsInfo.name, strlen(lfsInfo.name) + 1);
         if (lfsInfo.type == LFS_TYPE_DIR) {
-            g_nameValue.d_type = DT_DIR;
+            dent->d_type = DT_DIR;
         } else if (lfsInfo.type == LFS_TYPE_REG) {
-            g_nameValue.d_type = DT_REG;
+            dent->d_type = DT_REG;
         }
 
-        g_nameValue.d_reclen = lfsInfo.size;
+        dent->d_reclen = lfsInfo.size;
         pthread_mutex_unlock(&g_FslocalMutex);
 
-        return &g_nameValue;
+        return VFS_OK;
     }
 
     if (ret != 0) {
         errno = LittlefsErrno(ret);
     }
 
-    return NULL;
+    return VFS_ERROR;
 }
 
-int LfsClosedir(DIR *dir)
+int LfsClosedir(struct Dir *dir)
 {
     int ret;
-    FileDirInfo *dirInfo = (FileDirInfo *)dir;
 
-    if (dirInfo == NULL || dirInfo->lfsHandle == NULL) {
+    if (dir == NULL || dir->dMp == NULL || dir->dMp->mData == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    if (dir->dData == NULL) {
         errno = EBADF;
         return VFS_ERROR;
     }
 
-    ret = lfs_dir_close(dirInfo->lfsHandle, (lfs_dir_t *)(&(dirInfo->dir)));
+    lfs_t *lfs = (lfs_t *)dir->dMp->mData;
+    lfs_dir_t *dirInfo = (lfs_dir_t *)dir->dData;
 
-    FreeDirInfo(dirInfo->dirName);
+    ret = lfs_dir_close(lfs, dirInfo);
 
     if (ret != 0) {
         errno = LittlefsErrno(ret);
@@ -573,64 +397,58 @@ int LfsClosedir(DIR *dir)
     return ret;
 }
 
-int LfsOpen(const char *pathName, int openFlag, int mode)
+int LfsOpen(struct File *file, const char *pathName, int openFlag)
 {
-    int fd = INVALID_FD;
-    int err = INVALID_FD;
-
-    struct FileOpInfo *fileOpInfo = NULL;
+    int ret;
+    lfs_file_t *lfsHandle = NULL;
 
-    if (pathName == NULL) {
+    if (pathName == NULL || file == NULL || file->fMp == NULL ||
+        file->fMp->mData == NULL) {
         errno = EFAULT;
-        goto errout;
-    }
-
-    if (CheckPathIsMounted(pathName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
-        errno = ENOENT;
-        goto errout;
-    }
-    // if file is already open, return invalid fd
-    if (CheckFileIsOpen(pathName)) {
-        errno = EBUSY;
-        goto errout;
+        return VFS_ERROR;
     }
 
-    LittleFsHandleStruct *fsHandle = LfsAllocFd(pathName, &fd);
-    if (fd == INVALID_FD) {
-        errno = ENFILE;
-        goto errout;
+    lfsHandle = (lfs_file_t *)malloc(sizeof(lfs_file_t));
+    if (lfsHandle == NULL) {
+        errno = ENOMEM;
+        return VFS_ERROR;
     }
 
     int lfsOpenFlag = ConvertFlagToLfsOpenFlag(openFlag);
-    err = lfs_file_open(&(fileOpInfo->lfsInfo), &(fsHandle->file), pathName, lfsOpenFlag);
-    if (err != 0) {
-        LfsFreeFd(fd);
-        errno = LittlefsErrno(err);
+    ret = lfs_file_open((lfs_t *)file->fMp->mData, lfsHandle, pathName, lfsOpenFlag);
+    if (ret != 0) {
+        free(lfsHandle);
+        errno = LittlefsErrno(ret);
         goto errout;
     }
 
-    g_handle[fd].lfsHandle = &(fileOpInfo->lfsInfo);
-    return fd;
+    file->fData = (void *)lfsHandle;
+    return ret;
 
 errout:
     return INVALID_FD;
 }
 
-int LfsRead(int fd, void *buf, unsigned int len)
+int LfsRead(struct File *file, char *buf, size_t len)
 {
     int ret;
+    struct MountPoint *mp = NULL;
+    lfs_file_t *lfsHandle = NULL;
 
     if (buf == NULL) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    if (LfsFdIsValid(fd) == FALSE) {
+    if (file == NULL || file->fData == NULL) {
         errno = EBADF;
         return VFS_ERROR;
     }
 
-    ret = lfs_file_read(g_handle[fd].lfsHandle, &(g_handle[fd].file), buf, len);
+    lfsHandle = (lfs_file_t *)file->fData;
+    mp = file->fMp;
+
+    ret = lfs_file_read((lfs_t *)mp->mData, lfsHandle, buf, len);
     if (ret < 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -638,21 +456,26 @@ int LfsRead(int fd, void *buf, unsigned int len)
     return ret;
 }
 
-int LfsWrite(int fd, const void *buf, unsigned int len)
+int LfsWrite(struct File *file, const char *buf, size_t len)
 {
     int ret;
+    struct MountPoint *mp = NULL;
+    lfs_file_t *lfsHandle = NULL;
 
     if (buf == NULL) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    if (LfsFdIsValid(fd) == FALSE) {
+    if (file == NULL || file->fData == NULL) {
         errno = EBADF;
         return VFS_ERROR;
     }
 
-    ret = lfs_file_write(g_handle[fd].lfsHandle, &(g_handle[fd].file), buf, len);
+    lfsHandle = (lfs_file_t *)file->fData;
+    mp = file->fMp;
+
+    ret = lfs_file_write((lfs_t *)mp->mData, lfsHandle, buf, len);
     if (ret < 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -660,16 +483,21 @@ int LfsWrite(int fd, const void *buf, unsigned int len)
     return ret;
 }
 
-off_t LfsSeek(int fd, off_t offset, int whence)
+off_t LfsSeek(struct File *file, off_t offset, int whence)
 {
     off_t ret;
+    struct MountPoint *mp = NULL;
+    lfs_file_t *lfsHandle = NULL;
 
-    if (LfsFdIsValid(fd) == FALSE) {
+    if (file == NULL || file->fData == NULL) {
         errno = EBADF;
         return VFS_ERROR;
     }
 
-    ret = (off_t)lfs_file_seek(g_handle[fd].lfsHandle, &(g_handle[fd].file), offset, whence);
+    lfsHandle = (lfs_file_t *)file->fData;
+    mp = file->fMp;
+
+    ret = (off_t)lfs_file_seek((lfs_t *)mp->mData, lfsHandle, offset, whence);
     if (ret < 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -678,45 +506,48 @@ off_t LfsSeek(int fd, off_t offset, int whence)
     return ret;
 }
 
-int LfsClose(int fd)
+int LfsClose(struct File *file)
 {
-    int ret;
+    INT32 ret;
+    struct MountPoint *mp = NULL;
+    lfs_file_t *lfsHandle = NULL;
 
-    if (LfsFdIsValid(fd) == FALSE) {
+    if (file == NULL || file->fData == NULL) {
         errno = EBADF;
         return VFS_ERROR;
     }
 
+    lfsHandle = (lfs_file_t *)file->fData;
+    mp = file->fMp;
+
     pthread_mutex_lock(&g_FslocalMutex);
-    ret = lfs_file_close(g_handle[fd].lfsHandle, &(g_handle[fd].file));
+    ret = lfs_file_close((lfs_t *)mp->mData, lfsHandle);
     pthread_mutex_unlock(&g_FslocalMutex);
 
-    LfsFreeFd(fd);
-
     if (ret != 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
     }
 
+    free(file->fData);
     return ret;
 }
 
-int LfsRename(const char *oldName, const char *newName)
+int LfsRename(struct MountPoint *mp, const char *oldName, const char *newName)
 {
     int ret;
-    struct FileOpInfo *fileOpInfo = NULL;
 
-    if (oldName == NULL || newName == NULL) {
+    if (mp == NULL || oldName == NULL || newName == NULL) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    if (CheckPathIsMounted(oldName, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+    if (mp->mData == NULL) {
         errno = ENOENT;
         return VFS_ERROR;
     }
 
-    ret = lfs_rename(&(fileOpInfo->lfsInfo), oldName, newName);
+    ret = lfs_rename((lfs_t *)mp->mData, oldName, newName);
     if (ret != 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -725,23 +556,22 @@ int LfsRename(const char *oldName, const char *newName)
     return ret;
 }
 
-int LfsStat(const char *path, struct stat *buf)
+int LfsStat(struct MountPoint *mp, const char *path, struct stat *buf)
 {
     int ret;
     struct lfs_info info;
-    struct FileOpInfo *fileOpInfo = NULL;
 
-    if (path == NULL || buf == NULL) {
+    if (mp == NULL || path == NULL || buf == NULL) {
         errno = EFAULT;
         return VFS_ERROR;
     }
 
-    if (CheckPathIsMounted(path, &fileOpInfo) == FALSE || fileOpInfo == NULL) {
+    if (mp->mData == NULL) {
         errno = ENOENT;
         return VFS_ERROR;
     }
 
-    ret = lfs_stat(&(fileOpInfo->lfsInfo), path, &info);
+    ret = lfs_stat((lfs_t *)mp->mData, path, &info);
     if (ret == 0) {
         buf->st_size = info.size;
         if (info.type == LFS_TYPE_REG) {
@@ -757,16 +587,23 @@ int LfsStat(const char *path, struct stat *buf)
     return ret;
 }
 
-int LfsFsync(int fd)
+int LfsSync(struct File *file)
 {
     int ret;
+    struct MountPoint *mp = NULL;
 
-    if (LfsFdIsValid(fd) == FALSE) {
+    if (file == NULL || file->fData == NULL) {
         errno = EBADF;
         return VFS_ERROR;
     }
 
-    ret = lfs_file_sync(g_handle[fd].lfsHandle, &(g_handle[fd].file));
+    if (file->fMp == NULL || file->fMp->mData == NULL) {
+        errno = EFAULT;
+        return VFS_ERROR;
+    }
+
+    mp = file->fMp;
+    ret = lfs_file_sync((lfs_t *)mp->mData, (lfs_file_t *)file->fData);
     if (ret != 0) {
         errno = LittlefsErrno(ret);
         ret = VFS_ERROR;
@@ -774,32 +611,43 @@ int LfsFsync(int fd)
     return ret;
 }
 
-int LfsFstat(int fd, struct stat *buf)
-{
-    int ret;
-    struct lfs_info info;
+struct MountOps g_lfsMnt = {
+    .mount = LfsMount,
+    .umount = LfsUmount,
+    .umount2 = NULL,
+    .statfs = NULL,
+};
 
-    if (buf == NULL) {
-        errno = EFAULT;
-        return FS_FAILURE;
-    }
+struct FileOps g_lfsFops = {
+    .open = LfsOpen,
+    .close = LfsClose,
+    .read = LfsRead,
+    .write = LfsWrite,
+    .lseek = LfsSeek,
+    .lseek64 = NULL,
+    .stat = LfsStat,
+    .truncate = NULL,
+    .unlink = LfsUnlink,
+    .rename = LfsRename,
+    .ioctl = NULL, /* not support */
+    .sync = LfsSync,
+//    .rmdir = LfsRmdir,
+    .opendir = LfsOpendir,
+    .readdir = LfsReaddir,
+    .closedir = LfsClosedir,
+//    .getattr = FatfsStat,
+    .mkdir = LfsMkdir,
+};
 
-    if (LfsFdIsValid(fd) == FALSE) {
-        errno = EBADF;
-        return VFS_ERROR;
-    }
+struct FsMgt g_lfsMgt = {
+    .fdisk = NULL,
+    .format = NULL,
+};
 
-    ret = lfs_stat(g_handle[fd].lfsHandle, g_handle[fd].pathName, &info);
-    if (ret == 0) {
-        buf->st_size = info.size;
-        if (info.type == LFS_TYPE_REG) {
-            buf->st_mode = S_IFREG;
-        } else {
-            buf->st_mode = S_IFDIR;
-        }
-    } else {
-        errno = LittlefsErrno(ret);
-        ret = VFS_ERROR;
-    }
-    return ret;
-}
\ No newline at end of file
+extern int LOS_FsRegister(const char *fsType, struct MountOps *fsMops,
+        struct FileOps *fsFops, struct FsMgt *fsMgt);
+
+void LfsInit(void)
+{
+    (void)LOS_FsRegister("littlefs", &g_lfsMnt, &g_lfsFops, &g_lfsMgt);
+}
diff --git a/components/fs/littlefs/lfs_api.h b/components/fs/littlefs/lfs_api.h
index a101217..fd41679 100644
--- a/components/fs/littlefs/lfs_api.h
+++ b/components/fs/littlefs/lfs_api.h
@@ -45,8 +45,6 @@
 
 #define INVALID_FD (-1)
 
-typedef unsigned mode_t;
-
 #ifndef VFS_ERROR
 #define VFS_ERROR (-1)
 #endif
@@ -55,6 +53,7 @@ typedef unsigned mode_t;
 #define VFS_OK  0
 #endif
 
+#if 0
 typedef struct {
     uint8_t useFlag;
     const char *pathName;
@@ -75,6 +74,7 @@ typedef struct {
     lfs_t *lfsHandle;
     lfs_dir_t dir;
 } FileDirInfo;
+#endif
 
 #define LITTLE_FS_MAX_OPEN_FILES 100
 #define LITTLE_FS_STANDARD_NAME_LENGTH 50
@@ -90,6 +90,7 @@ typedef struct {
 #define LFS_MAX_OPEN_DIRS 10
 #endif
 
+#if 0
 LittleFsHandleStruct *GetFreeFd(int *fd);
 
 int LfsMount(const char *source, const char *target, const char *fileSystemType, unsigned long mountflags,
@@ -110,7 +111,9 @@ int LfsClose(int fd);
 int LfsRename(const char *oldName, const char *newName);
 int LfsStat(const char *path, struct stat *buf);
 int LfsFsync(int fd);
-int LfsFstat(int fd, struct stat *buf);
+
+const struct FsMap *MountFindfs(const char *filesystemtype);
+#endif
 int SetDefaultMountPath(int pathNameIndex, const char* target);
 
 #endif /* _LFS_API_H_ */
diff --git a/components/fs/vfs/BUILD.gn b/components/fs/vfs/BUILD.gn
new file mode 100644
index 0000000..d8891d9
--- /dev/null
+++ b/components/fs/vfs/BUILD.gn
@@ -0,0 +1,47 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("//kernel/liteos_m/liteos.gni")
+
+module_switch = defined(LOSCFG_FS_VFS)
+module_name = get_path_info(rebase_path("."), "name")
+kernel_module(module_name) {
+    sources = [
+        "fs.c",
+        "fs_files.c",
+        "fs_init.c",
+        "fs_maps.c",
+        "fs_mount.c",
+        "partition.c",
+    ]
+}
+
+config("public") {
+    include_dirs = [ "." ]
+}
\ No newline at end of file
diff --git a/components/fs/vfs/Kconfig b/components/fs/vfs/Kconfig
new file mode 100644
index 0000000..b51be4b
--- /dev/null
+++ b/components/fs/vfs/Kconfig
@@ -0,0 +1,34 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+config FS_VFS
+    bool "Enable FS VFS"
+    default y
+    help
+      Answer Y to enable LiteOS support VFS.
diff --git a/components/fs/vfs/fs.c b/components/fs/vfs/fs.c
new file mode 100644
index 0000000..7048bb1
--- /dev/null
+++ b/components/fs/vfs/fs.c
@@ -0,0 +1,1449 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define _GNU_SOURCE 1
+#include "fs_operations.h"
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <sys/uio.h>
+#include "los_debug.h"
+#include "errno.h"
+#include "fcntl.h"
+#include "los_mux.h"
+#include "los_debug.h"
+#include "limits.h"
+#include "fs_files.h"
+#include "fs_maps.h"
+#include "fs_mount.h"
+#include "securec.h"
+
+#ifdef LOSCFG_NET_LWIP_SACK
+#include "lwipopts.h"
+#include "lwip/sockets.h"
+#define CONFIG_NSOCKET_DESCRIPTORS  LWIP_CONFIG_NUM_SOCKETS
+#else
+#define CONFIG_NSOCKET_DESCRIPTORS  0
+#endif
+
+#ifndef CONFIG_NFILE_DESCRIPTORS
+#define CONFIG_NFILE_DESCRIPTORS 256
+#endif
+
+#ifdef LOSCFG_RANDOM_DEV
+#include "hks_client.h"
+#define RANDOM_DEV_FD  CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS
+#define RANDOM_DEV_PATH  "/dev/random"
+#endif
+
+#ifdef __GNUC__
+#define WRAP(x) __wrap_##x
+#else
+#define WRAP(x) x
+#endif
+
+#define FREE_AND_SET_NULL(ptr) do { \
+    free(ptr);                      \
+    ptr = NULL;                     \
+} while (0)
+
+#ifndef O_NDELAY
+#define O_NDELAY O_NONBLOCK
+#endif
+
+#define LOS_FCNTL   (O_NONBLOCK | O_NDELAY | O_APPEND | O_SYNC)
+#define IOV_MAX_CNT 4
+
+UINT32 g_fsMutex;
+
+int VfsLock(void)
+{
+    if (LOS_MuxPend(g_fsMutex, LOS_WAIT_FOREVER) != LOS_OK) {
+        PRINTK("VfsLock failed!");
+        return LOS_NOK;
+    }
+
+    return LOS_OK;
+}
+
+void VfsUnlock(void)
+{
+    (void)LOS_MuxPost(g_fsMutex);
+}
+
+#ifdef LOSCFG_RANDOM_DEV
+/**
+ * @brief Get canonical form of a given path based on cwd(Current working directory).
+ *
+ * @param cwd Indicates the current working directory.
+ * @param path Indicates the path to be canonicalization.
+ * @param buf Indicates the pointer to the buffer where the result will be return.
+ * @param bufSize Indicates the size of the buffer.
+ * @return Returns the length of the canonical path.
+ *
+ * @attention if path is an absolute path, cwd is ignored. if cwd if not specified, it is assumed to be root('/').
+ *            if the buffer is not big enough the result will be truncated, but the return value will always be the
+ *            length of the canonical path.
+ */
+static size_t GetCanonicalPath(const char *cwd, const char *path, char *buf, size_t bufSize)
+{
+    size_t offset;
+    if (!path) {
+        path = "";
+    }
+
+    if (!cwd || path[0] == '/') {
+        cwd = "";
+    }
+
+    offset = strlen("///") + 1; // three '/' and one '\0'
+    size_t tmpLen = strlen(cwd) + strlen(path) + offset;
+    char *tmpBuf = (char *)malloc(tmpLen);
+    if (tmpBuf == NULL) {
+        return FS_SUCCESS;
+    }
+
+    if (-1 == sprintf_s(tmpBuf, tmpLen, "/%s/%s/", cwd, path)) {
+        free(tmpBuf);
+        return FS_SUCCESS;
+    }
+
+    char *p;
+    /* replace /./ to / */
+    offset = strlen("/./") - 1;
+    while ((p = strstr(tmpBuf, "/./")) != NULL) {
+        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
+            free(tmpBuf);
+            return FS_SUCCESS;
+        }
+    }
+
+    /* replace // to / */
+    while ((p = strstr(tmpBuf, "//")) != NULL) {
+        if (EOK != memmove_s(p, tmpLen - (p - tmpBuf), p + 1, tmpLen - (p - tmpBuf) - 1)) {
+            free(tmpBuf);
+            return FS_SUCCESS;
+        }
+    }
+
+    /* handle /../ (e.g., replace /aa/bb/../ to /aa/) */
+    offset = strlen("/../") - 1;
+    while ((p = strstr(tmpBuf, "/../")) != NULL) {
+        char *start = p;
+        while (start > tmpBuf && *(start - 1) != '/') {
+            --start;
+        }
+        if (EOK != memmove_s(start, tmpLen - (start - tmpBuf), p + offset, tmpLen - (p - tmpBuf) - offset)) {
+            free(tmpBuf);
+            return FS_SUCCESS;
+        }
+    }
+
+    size_t totalLen = strlen(tmpBuf);
+    /* strip the last / */
+    if (totalLen > 1 && tmpBuf[totalLen - 1] == '/') {
+        tmpBuf[--totalLen] = 0;
+    }
+
+    if (!buf || bufSize == 0) {
+        free(tmpBuf);
+        return totalLen;
+    }
+
+    if (EOK != memcpy_s(buf, bufSize, tmpBuf, (((totalLen + 1) > bufSize) ? bufSize : (totalLen + 1)))) {
+        free(tmpBuf);
+        return FS_SUCCESS;
+    }
+
+    buf[bufSize - 1] = 0;
+    free(tmpBuf);
+    return totalLen;
+}
+#endif
+
+
+int LOS_Open(const char *path, int flags)
+{
+    struct File *file = NULL;
+    int fd = -1;
+    const char *pathInMp = NULL;
+    struct MountPoint *mp = NULL;
+
+    if ((path == NULL) || (path[strlen(path) - 1] == '/')) {
+        return fd;
+    }
+
+    /* prevent fs/mp being removed while opening */
+    if (VfsLock() != LOS_OK) {
+        return fd;
+    }
+
+    file = LOS_FileGet();
+    mp = LOS_MpFind(path, &pathInMp);
+    if ((mp->mWriteEnable == FALSE) &&
+        (flags & (O_CREAT | O_WRONLY | O_RDWR))) {
+        /* can't create file in read only mp */
+        VFS_ERRNO_SET(EACCES);
+        return fd;
+    }
+
+    VfsUnlock();
+
+    if ((file == NULL) || (mp == NULL) || (pathInMp == NULL) ||
+        (*pathInMp == '\0') || (mp->mFs->fsFops == NULL) ||
+        (mp->mFs->fsFops->open == NULL)) {
+        return fd;
+    }
+
+    if ((LOS_MpLock(mp) != LOS_OK)) {
+        LOS_FilePut(file);
+        return fd;
+    }
+
+    file->fFlags = (UINT32)flags;
+    file->fOffset = 0;
+    file->fData = NULL;
+    file->fFops = mp->mFs->fsFops;
+    file->fMp = mp;
+    file->fOwner = LOS_CurTaskIDGet();
+    file->fullPath = path;
+
+    if (file->fFops->open(file, pathInMp, flags) == 0) {
+        mp->mRefs++;
+        fd = FileToFd(file);
+        file->fStatus = FILE_STATUS_READY; /* file now ready to use */
+    } else {
+        LOS_FilePut(file);
+    }
+    (void)LOS_MpUnlock(mp);
+
+    return fd;
+}
+
+/* attach to a file and then set new status */
+
+struct File *LOS_AttachFile(int fd, UINT32 status)
+{
+    struct File *file = NULL;
+
+    if ((fd < 0) || (fd >= LOS_MAX_FD)) {
+        VFS_ERRNO_SET(EBADF);
+        return file;
+    }
+
+    file = FdToFile(fd);
+    /*
+     * Prevent file closed after the checking of:
+     *
+     * if (file->fStatus == FILE_STATUS_READY)
+     *
+     * Because our g_files are not privated to one task, it may be operated
+     * by every task.
+     * So we should take the mutex of current mount point before operating it,
+     * but for now we don't know if this file is valid (FILE_STATUS_READY), if
+     * this file is not valid, the fMp may be incorrect. so
+     * we must check the status first, but this file may be closed/removed
+     * after the checking if the senquence is not correct.
+     *
+     * Consider the following code:
+     *
+     * LOS_AttachFileReady (...)
+     * {
+     *     if (file->fStatus == FILE_STATUS_READY) {
+     *         while (LOS_MpLock (file->fMp) != LOS_OK);
+     *         return file;
+     *     }
+     * }
+     *
+     * It is not safe:
+     *
+     * If current task is interrupted by an IRQ just after the checking and then
+     * a new task is swapped in and the new task just closed this file.
+     *
+     * So <g_fsMutex> is acquire first and then check if it is valid: if not, just
+     * return NULL (which means fail); If yes, the mutex for current mount point
+     * is qcquired. And the close operation will also set task to
+     * FILE_STATUS_CLOSING to prevent other tasks operate on this file (and also
+     * prevent other tasks pend on the mutex of this mount point for this file).
+     * At last <g_fsMutex> is released. And return the file handle (struct File *).
+     *
+     * As this logic used in almost all the operation routines, this routine is
+     * made to reduce the redundant code.
+     */
+    if ((file == NULL) || (file->fMp == NULL)) {
+        return NULL;
+    }
+    while (VfsLock() != LOS_OK) {
+    };
+    if (file->fMp == NULL) {
+        return file;
+    }
+    if (file->fStatus == FILE_STATUS_READY) {
+        while (LOS_MpLock(file->fMp) != LOS_OK) {
+        };
+        if (status != FILE_STATUS_READY) {
+            file->fStatus = status;
+        }
+    } else {
+        VFS_ERRNO_SET(EBADF);
+        file = NULL;
+    }
+
+    VfsUnlock();
+
+    return file;
+}
+
+struct File *LOS_AttachFileReady(int fd)
+{
+    return LOS_AttachFile(fd, FILE_STATUS_READY);
+}
+
+struct File *LOS_AttachFileWithStatus(int fd, int status)
+{
+    return LOS_AttachFile(fd, (UINT32)status);
+}
+
+void LOS_DetachFile(const struct File *file)
+{
+    if ((file == NULL) || (file->fMp == NULL)) {
+        return;
+    }
+    (void)LOS_MpUnlock(file->fMp);
+}
+
+int LOS_Close(int fd)
+{
+    struct File *file;
+    int ret = -1;
+
+    file = LOS_AttachFileWithStatus(fd, FILE_STATUS_CLOSING);
+    if (file == NULL) {
+        return ret;
+    }
+
+    if ((file->fFops != NULL) && (file->fFops->close != NULL)) {
+        ret = file->fFops->close(file);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    if ((ret == 0) && (file->fMp != NULL)) {
+        file->fMp->mRefs--;
+    }
+
+    LOS_DetachFile(file);
+
+    LOS_FilePut(file);
+
+    return ret;
+}
+
+ssize_t LOS_Read(int fd, char *buff, size_t bytes)
+{
+    struct File *file = NULL;
+    ssize_t ret = (ssize_t)-1;
+
+    if ((buff == NULL) || (bytes == 0)) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    file = LOS_AttachFileReady(fd);
+    if (file == NULL) {
+        return ret;
+    }
+
+    if ((file->fFlags & O_ACCMODE) == O_WRONLY) {
+        VFS_ERRNO_SET(EACCES);
+    } else if ((file->fFops != NULL) && (file->fFops->read != NULL)) {
+        ret = file->fFops->read(file, buff, bytes);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    /* else ret will be -1 */
+    LOS_DetachFile(file);
+
+    return ret;
+}
+
+ssize_t LOS_Write(int fd, const void *buff, size_t bytes)
+{
+    struct File *file = NULL;
+    ssize_t ret = -1;
+
+    if ((buff == NULL) || (bytes == 0)) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    file = LOS_AttachFileReady(fd);
+    if (file == NULL) {
+        return ret;
+    }
+
+    if ((file->fFlags & O_ACCMODE) == O_RDONLY) {
+        VFS_ERRNO_SET(EACCES);
+    } else if ((file->fFops != NULL) && (file->fFops->write != NULL)) {
+        ret = file->fFops->write(file, buff, bytes);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    /* else ret will be -1 */
+    LOS_DetachFile(file);
+
+    return ret;
+}
+
+off_t LOS_Lseek(int fd, off_t off, int whence)
+{
+    struct File *file;
+    off_t ret = -1;
+
+    file = LOS_AttachFileReady(fd);
+    if (file == NULL) {
+        return ret;
+    }
+
+    if ((file->fFops == NULL) || (file->fFops->lseek == NULL)) {
+        ret = file->fOffset;
+    } else {
+        ret = file->fFops->lseek(file, off, whence);
+    }
+
+    LOS_DetachFile(file);
+
+    return ret;
+}
+#if 0
+off64_t LOS_Lseek64(int fd, off64_t off, int whence)
+{
+    struct File *file;
+    off64_t ret = -1;
+
+    file = LOS_AttachFileReady(fd);
+    if ((file == NULL) || (file->fFops == NULL)) {
+        return ret;
+    }
+    if (file->fFops->lseek64 == NULL) {
+        ret = file->fOffset64;
+    } else {
+        ret = file->fFops->lseek64(file, off, whence);
+    }
+
+    LOS_DetachFile(file);
+
+    return ret;
+}
+#endif
+
+int LOS_Stat(const char *path, struct stat *stat)
+{
+    struct MountPoint *mp = NULL;
+    const char *pathInMp = NULL;
+    int ret = -1;
+
+    if ((path == NULL) || (stat == NULL)) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    if (VfsLock() != LOS_OK) {
+        VFS_ERRNO_SET(EAGAIN);
+        return ret;
+    }
+
+    mp = LOS_MpFind(path, &pathInMp);
+    if ((mp == NULL) || (pathInMp == NULL) || (*pathInMp == '\0')) {
+        VFS_ERRNO_SET(ENOENT);
+        VfsUnlock();
+        return ret;
+    }
+
+    if (mp->mFs->fsFops->stat != NULL) {
+        ret = mp->mFs->fsFops->stat(mp, pathInMp, stat);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    VfsUnlock();
+
+    return ret;
+}
+
+int LOS_Statfs(const char *path, struct statfs *buf)
+{
+    struct MountPoint *mp = NULL;
+    const char *pathInMp = NULL;
+    int ret = -1;
+
+    if ((path == NULL) || (buf == NULL)) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    if (VfsLock() != LOS_OK) {
+        VFS_ERRNO_SET(EAGAIN);
+        return ret;
+    }
+
+    mp = LOS_MpFind(path, &pathInMp);
+    if ((mp == NULL) || (pathInMp == NULL) || (*pathInMp == '\0')) {
+        VFS_ERRNO_SET(ENOENT);
+        VfsUnlock();
+        return ret;
+    }
+
+    if (mp->mFs->fsFops->stat != NULL) {
+        ret = mp->mFs->fsMops->statfs(pathInMp, buf);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    VfsUnlock();
+
+    return ret;
+
+
+}
+
+int LOS_Truncate(int fd, off_t length)
+{
+    int ret = LOS_NOK;
+    struct File *file = NULL;
+
+    if (length <= 0) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    file = LOS_AttachFileReady(fd);
+    if (file == NULL) {
+        return ret;
+    }
+
+    if (file->fMp->mWriteEnable == FALSE) {
+        VFS_ERRNO_SET(EACCES);
+        LOS_DetachFile(file);
+        return ret;
+    }
+
+    if ((file->fFlags & O_ACCMODE) == O_RDONLY) {
+        VFS_ERRNO_SET(EACCES);
+    } else if ((file->fFops != NULL) && (file->fFops->truncate != NULL)) {
+        ret = file->fFops->truncate(file, length);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    /* else ret will be -1 */
+    LOS_DetachFile(file);
+    return ret;
+}
+
+int LOS_Unlink(const char *path)
+{
+    struct MountPoint *mp = NULL;
+    const char *pathInMp = NULL;
+    int ret = -1;
+
+    if (path == NULL) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    (void)VfsLock(); /* prevent the file open/rename */
+
+    mp = LOS_MpFind(path, &pathInMp);
+    if ((mp == NULL) || (pathInMp == NULL) || (*pathInMp == '\0') || (mp->mFs->fsFops->unlink == NULL)) {
+        VFS_ERRNO_SET(ENOENT);
+        VfsUnlock();
+        return ret;
+    }
+
+    ret = mp->mFs->fsFops->unlink(mp, pathInMp);
+
+    VfsUnlock();
+    return ret;
+}
+
+int LOS_Rename(const char *old, const char *new)
+{
+    struct MountPoint *mpOld = NULL;
+    struct MountPoint *mpNew = NULL;
+    const char *pathInMpOld = NULL;
+    const char *pathInMpNew = NULL;
+    int ret = -1;
+
+    if ((old == NULL) || (new == NULL)) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    (void)VfsLock(); /* prevent file open/unlink */
+
+    mpOld = LOS_MpFind(old, &pathInMpOld);
+
+    if (pathInMpOld == NULL) {
+        VFS_ERRNO_SET(EINVAL);
+        VfsUnlock();
+        return ret;
+    }
+
+    if ((mpOld == NULL) || (*pathInMpOld == '\0') || (mpOld->mFs->fsFops->unlink == NULL)) {
+        VFS_ERRNO_SET(EINVAL);
+        VfsUnlock();
+        return ret;
+    }
+
+    mpNew = LOS_MpFind(new, &pathInMpNew);
+    if ((mpNew == NULL) || (pathInMpNew == NULL) || (*pathInMpNew == '\0') || (mpNew->mFs->fsFops->unlink == NULL)) {
+        VFS_ERRNO_SET(EINVAL);
+        VfsUnlock();
+        return ret;
+    }
+
+    if (mpOld != mpNew) {
+        VFS_ERRNO_SET(EXDEV);
+        VfsUnlock();
+        return ret;
+    }
+
+    if (mpOld->mFs->fsFops->rename != NULL) {
+        ret = mpOld->mFs->fsFops->rename(mpOld, pathInMpOld, pathInMpNew);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    VfsUnlock();
+    return ret;
+}
+
+int LOS_Ioctl(int fd, int func, ...)
+{
+    va_list ap;
+    unsigned long arg;
+    struct File *file = NULL;
+    int ret = -1;
+
+    va_start(ap, func);
+    arg = va_arg(ap, unsigned long);
+    va_end(ap);
+
+    file = LOS_AttachFileReady(fd);
+    if (file == NULL) {
+        return ret;
+    }
+
+    if ((file->fFops != NULL) && (file->fFops->ioctl != NULL)) {
+        ret = file->fFops->ioctl(file, func, arg);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    LOS_DetachFile(file);
+
+    return ret;
+}
+
+int LOS_Sync(int fd)
+{
+    struct File *file;
+    int ret = -1;
+
+    file = LOS_AttachFileReady(fd);
+    if (file == NULL) {
+        return ret;
+    }
+
+    if (file->fMp->mWriteEnable == FALSE) {
+        VFS_ERRNO_SET(EACCES);
+        LOS_DetachFile(file);
+        return ret;
+    }
+
+    if ((file->fFops != NULL) && (file->fFops->sync != NULL)) {
+        ret = file->fFops->sync(file);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    LOS_DetachFile(file);
+
+    return ret;
+}
+
+DIR *LOS_Opendir(const char *path)
+{
+    struct MountPoint *mp = NULL;
+    const char *pathInMp = NULL;
+    struct Dir *dir = NULL;
+    UINT32 ret;
+
+    if (path == NULL) {
+        VFS_ERRNO_SET(EINVAL);
+        return NULL;
+    }
+
+    dir = (struct Dir *)malloc(sizeof(struct Dir));
+    if (dir == NULL) {
+        PRINTK("fail to malloc memory in VFS, <malloc.c> is needed,"
+               "make sure it is added\n");
+        VFS_ERRNO_SET(ENOMEM);
+        return NULL;
+    }
+
+    if (VfsLock() != LOS_OK) {
+        VFS_ERRNO_SET(EAGAIN);
+        free(dir);
+        return NULL;
+    }
+
+    mp = LOS_MpFind(path, &pathInMp);
+    if ((mp == NULL) || (pathInMp == NULL)) {
+        VFS_ERRNO_SET(ENOENT);
+        VfsUnlock();
+        free(dir);
+        return NULL;
+    }
+
+    ret = LOS_MpLock(mp);
+
+    VfsUnlock();
+
+    if ((ret != LOS_OK) || (mp->mFs->fsFops->opendir == NULL)) {
+        VFS_ERRNO_SET(ENOTSUP);
+        (void)LOS_MpUnlock(mp);
+        free(dir);
+        return NULL;
+    }
+
+    dir->dMp = mp;
+    dir->dOffset = 0;
+
+    ret = (UINT32)mp->mFs->fsFops->opendir(dir, pathInMp);
+    if (ret == 0) {
+        mp->mRefs++;
+    } else {
+        free(dir);
+        dir = NULL;
+    }
+
+    (void)LOS_MpUnlock(mp);
+
+    return (DIR *)dir;
+}
+
+struct dirent *LOS_Readdir(DIR *d)
+{
+    struct MountPoint *mp = NULL;
+    struct dirent *ret = NULL;
+    struct Dir *dir = (struct Dir *)d;
+
+    if ((dir == NULL) || (dir->dMp == NULL)) {
+        VFS_ERRNO_SET(EINVAL);
+        return NULL;
+    }
+
+    mp = dir->dMp;
+
+    if (LOS_MpLock(mp) != LOS_OK) {
+        VFS_ERRNO_SET(EAGAIN);
+        return NULL;
+    }
+
+    if ((dir->dMp->mFs != NULL) && (dir->dMp->mFs->fsFops != NULL) &&
+        (dir->dMp->mFs->fsFops->readdir != NULL)) {
+        if (dir->dMp->mFs->fsFops->readdir(dir, &dir->dDent) == 0) {
+            ret = &dir->dDent;
+        } else {
+            VFS_ERRNO_SET(EBADF);
+        }
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    (void)LOS_MpUnlock(mp);
+
+    return ret;
+}
+
+int LOS_Closedir(DIR *d)
+{
+    struct MountPoint *mp = NULL;
+    int ret = -1;
+    struct Dir *dir = (struct Dir *)d;
+
+    if ((dir == NULL) || (dir->dMp == NULL)) {
+        VFS_ERRNO_SET(EBADF);
+        return ret;
+    }
+
+    mp = dir->dMp;
+
+    if (LOS_MpLock(mp) != LOS_OK) {
+        VFS_ERRNO_SET(EAGAIN);
+        return ret;
+    }
+
+    if ((dir->dMp->mFs != NULL) && (dir->dMp->mFs->fsFops != NULL) &&
+        (dir->dMp->mFs->fsFops->closedir != NULL)) {
+        ret = dir->dMp->mFs->fsFops->closedir(dir);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+    }
+
+    if (ret == 0) {
+        mp->mRefs--;
+    } else {
+        VFS_ERRNO_SET(EBADF);
+    }
+    (void)LOS_MpUnlock(mp);
+    free(dir);
+    dir = NULL;
+    return ret;
+}
+
+int LOS_Mkdir(const char *path, int mode)
+{
+    struct MountPoint *mp = NULL;
+    const char *pathInMp = NULL;
+    int ret = -1;
+    (void)mode;
+
+    if (path == NULL) {
+        VFS_ERRNO_SET(EINVAL);
+        return ret;
+    }
+
+    if (VfsLock() != LOS_OK) {
+        VFS_ERRNO_SET(EAGAIN);
+        return ret;
+    }
+
+    mp = LOS_MpFind(path, &pathInMp);
+    if ((mp == NULL) || (pathInMp == NULL) || (*pathInMp == '\0')) {
+        VFS_ERRNO_SET(ENOENT);
+        VfsUnlock();
+        return ret;
+    }
+
+    ret = (int)LOS_MpLock(mp);
+    VfsUnlock();
+    if (ret != LOS_OK) {
+        VFS_ERRNO_SET(EAGAIN);
+        return -1;
+    }
+
+    if (mp->mFs->fsFops->mkdir != NULL) {
+        ret = mp->mFs->fsFops->mkdir(mp, pathInMp);
+    } else {
+        VFS_ERRNO_SET(ENOTSUP);
+        ret = -1;
+    }
+
+    (void)LOS_MpUnlock(mp);
+
+    return ret;
+}
+
+int LOS_Dup(int fd)
+{
+    int ret;
+    struct File *file1 = NULL;
+    struct File *file2 = NULL;
+    const char *mpath = NULL;
+    struct MountPoint *mp = NULL;
+
+    if ((fd < 0) || (fd > LOS_MAX_FD)) {
+        VFS_ERRNO_SET(EBADF);
+        return LOS_NOK;
+    }
+
+    file1 = LOS_AttachFileReady(fd);
+    if (file1 == NULL) {
+        return LOS_NOK;
+    }
+
+    file2 = LOS_FileGet();
+    if (file2 == NULL) {
+        LOS_DetachFile(file1);
+        VFS_ERRNO_SET(ENFILE);
+        return LOS_NOK;
+    }
+
+    file2->fFlags = file1->fFlags;
+    file2->fStatus = file1->fStatus;
+    file2->fOffset = file1->fOffset;
+    file2->fOwner = file1->fOwner;
+    file2->fData = file1->fData;
+    file2->fFops = file1->fFops;
+    file2->fMp = file1->fMp;
+
+    if ((file1->fMp == NULL) || (file1->fMp->mPath == NULL)) {
+        LOS_DetachFile(file1);
+        return LOS_NOK;
+    }
+    mp = LOS_MpFind(file1->fMp->mPath, &mpath);
+    if ((mp == NULL) || (file1->fFops == NULL)) {
+        LOS_DetachFile(file1);
+        return LOS_NOK;
+    }
+    ret = file1->fFops->open(file2, mpath, file1->fFlags);
+    LOS_DetachFile(file1);
+    return ret;
+}
+
+int LOS_Dup2(int oldFd, int newFd)
+{
+    struct File *file1 = NULL;
+    struct File *file2 = NULL;
+    const char *mpath = NULL;
+    struct MountPoint *mp = NULL;
+
+    file1 = LOS_AttachFileReady(oldFd);
+    if (file1 == NULL) {
+        return LOS_NOK;
+    }
+
+    /* Close the newFd if it is opening first */
+    file2 = LOS_AttachFileReady(newFd);
+    if (file2 != NULL) {
+        LOS_DetachFile(file1);
+        LOS_DetachFile(file2);
+        (void)LOS_Close(newFd);
+        return LOS_NOK;
+    }
+
+    file2 = LOS_FileGetSpec(newFd);
+    if (file2 == NULL) {
+        VFS_ERRNO_SET(ENFILE);
+        PRINTK("files no free!\n");
+        LOS_DetachFile(file1);
+        return LOS_NOK;
+    }
+    if (oldFd == newFd) {
+        LOS_DetachFile(file1);
+        return oldFd;
+    }
+
+    file2->fFlags = file1->fFlags;
+    file2->fStatus = file1->fStatus;
+    file2->fOffset = file1->fOffset;
+    file2->fOwner = file1->fOwner;
+    file2->fData = file1->fData;
+    file2->fFops = file1->fFops;
+    file2->fMp = file1->fMp;
+
+    if ((file1->fMp == NULL) || (file1->fMp->mPath == NULL)) {
+        LOS_DetachFile(file1);
+        return LOS_NOK;
+    }
+    mp = LOS_MpFind(file1->fMp->mPath, &mpath);
+    if ((mp == NULL) || (file1->fFops == NULL)) {
+        LOS_DetachFile(file1);
+        return LOS_NOK;
+    }
+    file1->fFops->open(file2, mpath, file1->fFlags);
+    LOS_DetachFile(file1);
+
+    return newFd;
+}
+
+int LOS_Vfcntl(struct File *filep, int cmd, va_list ap)
+{
+    int ret;
+    int fd;
+    UINT32 flags;
+
+    if ((filep == NULL) || (filep->fFops == NULL)) {
+        return -EBADF;
+    }
+
+    if (cmd == F_DUPFD) {
+        fd = FileToFd(filep);
+        ret = LOS_Dup(fd);
+    } else if (cmd == F_GETFL) {
+        ret = (int)(filep->fFlags);
+    } else if (cmd == F_SETFL) {
+        flags = (UINT32)va_arg(ap, int);
+        flags &= LOS_FCNTL;
+        filep->fFlags &= ~LOS_FCNTL;
+        filep->fFlags |= flags;
+        ret = LOS_OK;
+    } else {
+        ret = -ENOSYS;
+    }
+    return ret;
+}
+
+static int MapToPosixRet(int ret)
+{
+    return ((ret) < 0 ? -1 : (ret));
+}
+
+#if 0
+/* POSIX interface */
+int WRAP(open)(const char *path, int flags, ...)
+{
+#ifdef LOSCFG_RANDOM_DEV
+    unsigned flags = O_RDONLY | O_WRONLY | O_RDWR | O_APPEND | O_CREAT | O_LARGEFILE | O_TRUNC | O_EXCL | O_DIRECTORY;
+    if ((unsigned)oflag & ~flags) {
+        errno = EINVAL;
+        return FS_FAILURE;
+    }
+
+    size_t pathLen = strlen(path) + 1;
+    char *canonicalPath = (char *)malloc(pathLen);
+    if (!canonicalPath) {
+        errno = ENOMEM;
+        return FS_FAILURE;
+    }
+    if (GetCanonicalPath(NULL, path, canonicalPath, pathLen) == 0) {
+        FREE_AND_SET_NULL(canonicalPath);
+        errno = ENOMEM;
+        return FS_FAILURE;
+    }
+
+    if (strcmp(canonicalPath, RANDOM_DEV_PATH) == 0) {
+        FREE_AND_SET_NULL(canonicalPath);
+        if ((O_ACCMODE & (unsigned)oflag) != O_RDONLY) {
+            errno = EPERM;
+            return FS_FAILURE;
+        }
+        if ((unsigned)oflag & O_DIRECTORY) {
+            errno = ENOTDIR;
+            return FS_FAILURE;
+        }
+        return RANDOM_DEV_FD;
+    }
+    if (strcmp(canonicalPath, "/") == 0 || strcmp(canonicalPath, "/dev") == 0) {
+        FREE_AND_SET_NULL(canonicalPath);
+        if ((unsigned)oflag & O_DIRECTORY) {
+            errno = EPERM;
+            return FS_FAILURE;
+        }
+        errno = EISDIR;
+        return FS_FAILURE;
+    }
+    FREE_AND_SET_NULL(canonicalPath);
+#endif
+    int ret = LOS_Open(path, flags);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(close)(int fd)
+{
+#ifdef LOSCFG_RANDOM_DEV
+    if (fd == RANDOM_DEV_FD) {
+        return FS_SUCCESS;
+    }
+#endif
+#ifdef LOSCFG_NET_LWIP_SACK
+    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
+        return closesocket(fd);
+    }
+#endif /* LOSCFG_NET_LWIP_SACK */
+
+    int ret = LOS_NOK;
+
+    if (fd >= 0 && fd < CONFIG_NFILE_DESCRIPTORS) {
+        ret = LOS_Close(fd);
+    }
+    return MapToPosixRet(ret);
+}
+
+ssize_t WRAP(read)(int fd, void *buff, size_t bytes)
+{
+    ssize_t ret = LOS_NOK;
+    if (fd >= 0 && fd < CONFIG_NFILE_DESCRIPTORS) {
+        ret = LOS_Read(fd, buff, bytes);
+    }
+
+#ifdef LOSCFG_NET_LWIP_SACK
+    if (fd >= CONFIG_NFILE_DESCRIPTORS && fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
+        return recv(fd, buff, bytes, 0);
+    }
+#endif /* LOSCFG_NET_LWIP_SACK */
+    return MapToPosixRet(ret);
+}
+
+ssize_t WRAP(write)(int fd, const void *buff, size_t bytes)
+{
+#ifdef LOSCFG_RANDOM_DEV
+    if (fd == RANDOM_DEV_FD) {
+        errno = EBADF; /* "/dev/random" is readonly */
+        return FS_FAILURE;
+    }
+#endif
+    ssize_t ret = LOS_NOK;
+    if (fd >= 0 && fd < CONFIG_NFILE_DESCRIPTORS) {
+        ret = LOS_Write(fd, buff, bytes);
+    }
+
+#ifdef LOSCFG_NET_LWIP_SACK
+    if (fd >= CONFIG_NFILE_DESCRIPTORS &&
+        fd < (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)) {
+        return send(fd, buff, bytes, 0);
+    }
+#endif /* LOSCFG_NET_LWIP_SACK */
+
+    return MapToPosixRet(ret);
+}
+
+off_t WRAP(lseek)(int fd, off_t off, int whence)
+{
+    off_t ret = LOS_Lseek(fd, off, whence);
+    return ret;
+}
+
+off64_t lseek64(int fd, off64_t off, int whence)
+{
+    off64_t ret = LOS_Lseek64(fd, off, whence);
+    return ret;
+}
+
+int WRAP(stat)(const char *path, struct stat *stat)
+{
+    int ret = LOS_Stat(path, stat);
+    return MapToPosixRet(ret);
+}
+
+int statfs(const char *path, struct statfs *buf)
+{
+    int ret = LOS_Statfs(path, buf);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(unlink)(const char *path)
+{
+    int ret = LOS_Unlink(path);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(rename)(const char *oldpath, const char *newpath)
+{
+    int ret = LOS_Rename(oldpath, newpath);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(fsync)(int fd)
+{
+    int ret = LOS_Sync(fd);
+    return MapToPosixRet(ret);
+}
+
+DIR *WRAP(opendir)(const char *path)
+{
+    return LOS_Opendir(path);
+}
+
+struct dirent *WRAP(readdir)(DIR *dir)
+{
+    return LOS_Readdir(dir);
+}
+
+int WRAP(closedir)(DIR *dir)
+{
+    int ret = LOS_Closedir(dir);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(mkdir)(const char *path, mode_t mode)
+{
+    int ret = LOS_Mkdir(path, (int)mode);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(rmdir)(const char *path)
+{
+    int ret = LOS_Unlink(path);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(dup)(int fd)
+{
+    int ret = LOS_Dup(fd);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(dup2)(int oldFd, int newFd)
+{
+    int ret = LOS_Dup2(oldFd, newFd);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(lstat)(const char *path, struct stat *buffer)
+{
+    return stat(path, buffer);
+}
+#endif
+
+int LOS_Fstat(int fd, struct stat *buf)
+{
+    struct File *filep;
+    int ret;
+    filep = LOS_AttachFileReady(fd);
+    if ((filep == NULL) || (filep->fMp == NULL) || filep->fullPath == NULL) {
+        return FS_FAILURE;
+    }
+    ret = stat(filep->fullPath, buf);
+    LOS_DetachFile(filep);
+    return ret;
+}
+
+#if 0
+int WRAP(fstat)(int fd, struct stat *buf)
+{
+    return LOS_Fstat(fd, buf);
+}
+
+int fcntl(int fd, int cmd, ...)
+{
+    struct File *filep = NULL;
+    va_list ap;
+    int ret;
+    va_start(ap, cmd);
+
+    if (fd < CONFIG_NFILE_DESCRIPTORS) {
+        filep = LOS_AttachFileReady(fd);
+        ret = LOS_Vfcntl(filep, cmd, ap);
+        LOS_DetachFile(filep);
+    } else {
+        ret = -EBADF;
+#ifdef LOSCFG_NET_LWIP_SACK
+        int arg = va_arg(ap, int);
+        ret = lwip_fcntl(fd, (long)cmd, arg);
+        return ret;
+#endif /* LOSCFG_NET_LWIP_SACK */
+    }
+
+    va_end(ap);
+
+    if (ret < 0) {
+        set_errno(-ret);
+        ret = FS_FAILURE;
+    }
+    return ret;
+}
+
+int ioctl(int fd, int func, ...)
+{
+    int ret;
+    va_list ap;
+    va_start(ap, func);
+    if (fd < CONFIG_NFILE_DESCRIPTORS) {
+        ret = LOS_Ioctl(fd, func, ap);
+    } else {
+        ret = -EBADF;
+#ifdef LOSCFG_NET_LWIP_SACK
+        UINTPTR arg = va_arg(ap, UINTPTR);
+        ret = lwip_ioctl(fd, (long)func, (void *)arg);
+        return ret;
+#endif /* LOSCFG_NET_LWIP_SACK */
+    }
+
+    va_end(ap);
+    return ret;
+}
+
+ssize_t readv(int fd, const struct iovec *iov, int iovcnt)
+{
+    int i;
+    int ret;
+    char *buf = NULL;
+    char *curBuf = NULL;
+    char *readBuf = NULL;
+    size_t bufLen = 0;
+    size_t bytesToRead;
+    ssize_t totalBytesRead;
+    size_t totalLen;
+
+    if ((iov == NULL) || (iovcnt <= 0) || (iovcnt > IOV_MAX_CNT)) {
+        return FS_FAILURE;
+    }
+
+    for (i = 0; i < iovcnt; ++i) {
+        if ((SSIZE_MAX - bufLen) < iov[i].iov_len) {
+            return FS_FAILURE;
+        }
+        bufLen += iov[i].iov_len;
+    }
+    if (bufLen == 0) {
+        return FS_FAILURE;
+    }
+    totalLen = bufLen * sizeof(char);
+    buf = (char *)malloc(totalLen);
+    if (buf == NULL) {
+        return FS_FAILURE;
+    }
+
+    totalBytesRead = read(fd, buf, bufLen);
+    if ((size_t)totalBytesRead < totalLen) {
+        totalLen = (size_t)totalBytesRead;
+    }
+    curBuf = buf;
+    for (i = 0; i < iovcnt; ++i) {
+        readBuf = (char *)iov[i].iov_base;
+        bytesToRead = iov[i].iov_len;
+
+        size_t lenToRead = totalLen < bytesToRead ? totalLen : bytesToRead;
+        ret = memcpy_s(readBuf, bytesToRead, curBuf, lenToRead);
+        if (ret != LOS_OK) {
+            free(buf);
+            return FS_FAILURE;
+        }
+        if (totalLen < (size_t)bytesToRead) {
+            break;
+        }
+        curBuf += bytesToRead;
+        totalLen -= bytesToRead;
+    }
+    free(buf);
+    return totalBytesRead;
+}
+
+ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
+{
+    int i;
+    int ret;
+    char *buf = NULL;
+    char *curBuf = NULL;
+    char *writeBuf = NULL;
+    size_t bufLen = 0;
+    size_t bytesToWrite;
+    ssize_t totalBytesWritten;
+    size_t totalLen;
+
+    if ((iov == NULL) || (iovcnt <= 0) || (iovcnt > IOV_MAX_CNT)) {
+        return FS_FAILURE;
+    }
+
+    for (i = 0; i < iovcnt; ++i) {
+        if ((SSIZE_MAX - bufLen) < iov[i].iov_len) {
+            set_errno(EINVAL);
+            return FS_FAILURE;
+        }
+        bufLen += iov[i].iov_len;
+    }
+    if (bufLen == 0) {
+        return FS_FAILURE;
+    }
+    totalLen = bufLen * sizeof(char);
+    buf = (char *)malloc(totalLen);
+    if (buf == NULL) {
+        return FS_FAILURE;
+    }
+    curBuf = buf;
+    for (i = 0; i < iovcnt; ++i) {
+        writeBuf = (char *)iov[i].iov_base;
+        bytesToWrite = iov[i].iov_len;
+        if (((ssize_t)totalLen <= 0) || ((ssize_t)bytesToWrite <= 0)) {
+            continue;
+        }
+        ret = memcpy_s(curBuf, totalLen, writeBuf, bytesToWrite);
+        if (ret != LOS_OK) {
+            free(buf);
+            return FS_FAILURE;
+        }
+        curBuf += bytesToWrite;
+        totalLen -= bytesToWrite;
+    }
+
+    totalBytesWritten = write(fd, buf, bufLen);
+    free(buf);
+
+    return totalBytesWritten;
+}
+
+int isatty(int fd)
+{
+    (void)fd;
+    return 0;
+}
+
+int access(const char *path, int amode)
+{
+    int result;
+    mode_t mode;
+    struct stat buf;
+
+    result = stat(path, &buf);
+    if (result != 0) {
+        return -1;
+    }
+
+    mode = buf.st_mode;
+    if ((unsigned int)amode & R_OK) {
+        if ((mode & (S_IROTH | S_IRGRP | S_IRUSR)) == 0) {
+            set_errno(EACCES);
+            return -1;
+        }
+    }
+    if ((unsigned int)amode & W_OK) {
+        if ((mode & (S_IWOTH | S_IWGRP | S_IWUSR)) == 0) {
+            set_errno(EACCES);
+            return -1;
+        }
+    }
+    if ((unsigned int)amode & X_OK) {
+        if ((mode & (S_IXOTH | S_IXGRP | S_IXUSR)) == 0) {
+            set_errno(EACCES);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+int WRAP(mount)(const char *source, const char *target,
+          const char *filesystemtype, unsigned long mountflags,
+          const void *data)
+{
+    int ret = LOS_FsMount(source, target, filesystemtype, mountflags, data);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(umount)(const char *target)
+{
+    int ret = LOS_FsUmount(target);
+    return MapToPosixRet(ret);
+}
+
+int WRAP(umount2)(const char *target, int flag)
+{
+    int ret = LOS_FsUmount2(target, flag);
+    return MapToPosixRet(ret);
+}
+#endif
diff --git a/components/fs/vfs/fs_conf.h b/components/fs/vfs/fs_conf.h
new file mode 100644
index 0000000..ceb9fc8
--- /dev/null
+++ b/components/fs/vfs/fs_conf.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _FS_CONF_H_
+#define _FS_CONF_H_
+
+#include "fcntl.h"
+#include "dirent.h"
+#include "unistd.h"
+#include "sys/mount.h"
+#include "sys/stat.h"
+#include "sys/statfs.h"
+
+#define LOS_FD_OFFSET 3 /* 0, 1, 2 is not in the file array */
+#define LOS_MAX_FD 8 // TODO:
+#define LOS_MAX_FILES 8
+#define MAX_FILESYSTEM_LEN 2
+#define LOS_MAX_DIR_NAME_LEN 128 // TODO:
+#endif /* _FS_CONF_H_ */
diff --git a/components/fs/vfs/fs_files.c b/components/fs/vfs/fs_files.c
new file mode 100644
index 0000000..24a0676
--- /dev/null
+++ b/components/fs/vfs/fs_files.c
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "fs_files.h"
+#include "fs_operations.h"
+#include "fs_conf.h"
+#include "los_config.h"
+#include "errno.h"
+//#include "fcntl.h"
+//#include "securec.h"
+#include "stdio.h"
+#include "stdlib.h"
+#include "string.h"
+//#include "sys/mount.h"
+//#include "sys/statfs.h"
+//#include "sys/stat.h"
+//#include "unistd.h"
+
+#ifndef CONFIG_NFILE_DESCRIPTORS
+#define CONFIG_NFILE_DESCRIPTORS 256
+#endif
+
+struct File g_files[LOS_MAX_FILES];
+
+int FileToFd(struct File *file)
+{
+    if (file == NULL) {
+        return -1;
+    }
+    return file - g_files + LOS_FD_OFFSET;
+}
+
+struct File *FdToFile(int fd)
+{
+    if ((fd < LOS_FD_OFFSET) || (fd >= LOS_MAX_FD)) {
+        return NULL;
+    }
+    return &g_files[fd - LOS_FD_OFFSET];
+}
+
+struct File *LOS_FileGet(void)
+{
+    int i;
+    /* protected by g_fsMutex */
+    for (i = 0; i < LOS_MAX_FILES; i++) {
+        if (g_files[i].fStatus == FILE_STATUS_NOT_USED) {
+            g_files[i].fStatus = FILE_STATUS_INITING;
+            return &g_files[i];
+        }
+    }
+
+    return NULL;
+}
+
+struct File *LOS_FileGetSpec(int fd)
+{
+    if ((fd < LOS_FD_OFFSET) || (fd >= LOS_MAX_FD)) {
+        return NULL;
+    }
+    if (g_files[fd - LOS_FD_OFFSET].fStatus == FILE_STATUS_NOT_USED) {
+        g_files[fd - LOS_FD_OFFSET].fStatus = FILE_STATUS_INITING;
+        return &g_files[fd - LOS_FD_OFFSET];
+    }
+
+    return NULL;
+}
+
+void LOS_FilePut(struct File *file)
+{
+    if (file == NULL) {
+        return;
+    }
+    file->fFlags = 0;
+    file->fFops = NULL;
+    file->fData = NULL;
+    file->fMp = NULL;
+    file->fOffset = 0;
+    file->fOwner = -1;
+    file->fullPath = NULL;
+    file->fStatus = FILE_STATUS_NOT_USED;
+}
diff --git a/components/fs/vfs/fs_files.h b/components/fs/vfs/fs_files.h
new file mode 100644
index 0000000..5e4a1e5
--- /dev/null
+++ b/components/fs/vfs/fs_files.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _FS_FILES_H_
+#define _FS_FILES_H_
+
+//#include "fcntl.h"
+//#include "dirent.h"
+//#include "unistd.h"
+#include "fs_conf.h"
+#include "fs_mount.h"
+#include "fs_operations.h"
+#include "sys/stat.h"
+#include "los_compiler.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define off64_t off_t
+#define FILE_STATUS_NOT_USED 0
+#define FILE_STATUS_INITING 1
+#define FILE_STATUS_READY 2
+#define FILE_STATUS_CLOSING 3
+
+struct FileOps;
+struct File;
+struct Dir;
+struct dirent;
+
+struct FileOps {
+    int     (*open)(struct File *, const char *, int);
+    int     (*close)(struct File *);
+    ssize_t (*read)(struct File *, char *, size_t);
+    ssize_t (*write)(struct File *, const char *, size_t);
+    off_t   (*lseek)(struct File *, off_t, int);
+    off64_t (*lseek64)(struct File *, off64_t, int);
+    int     (*stat)(struct MountPoint *, const char *, struct stat *);
+    int     (*truncate)(struct File *, off_t);
+    int     (*unlink)(struct MountPoint *, const char *);
+    int     (*rename)(struct MountPoint *, const char *, const char *);
+    int     (*ioctl)(struct File *, int, unsigned long);
+    int     (*sync)(struct File *);
+    int     (*opendir)(struct Dir *, const char *);
+    int     (*readdir)(struct Dir *, struct dirent *);
+    int     (*closedir)(struct Dir *);
+    int     (*mkdir)(struct MountPoint *, const char *);
+    int     (*rmdir)(struct MountPoint *, const char *);
+};
+
+struct File {
+    const struct FileOps *fFops;
+    UINT32 fFlags;
+    UINT32 fStatus;
+    off_t fOffset;
+    INT32 fOwner;
+//    off64_t            fOffset64;
+    struct MountPoint *fMp;
+    void *fData; /* file system opreations handle, fatfs FIL, etc. */
+    const char *fullPath;
+};
+#if 0
+struct dirent {
+    char dName[LOS_MAX_DIR_NAME_LEN + 1];
+    UINT32 dType;
+    UINT32 dSize;
+};
+#endif
+
+struct Dir {
+    struct MountPoint *dMp;
+    struct dirent      dDent;
+    off_t              dOffset;
+    void              *dData;
+};
+
+int FileToFd(struct File *file);
+struct File *FdToFile(int fd);
+struct File *LOS_FileGet(void);
+struct File *LOS_FileGetSpec(int fd);
+void LOS_FilePut(struct File *file);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _FS_OPERATIONS_H_ */
diff --git a/components/fs/vfs/fs_init.c b/components/fs/vfs/fs_init.c
new file mode 100644
index 0000000..81ebb8d
--- /dev/null
+++ b/components/fs/vfs/fs_init.c
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "fs_maps.h"
+#include "stdlib.h"
+#include "securec.h"
+#include "fs_operations.h"
+#include "los_compiler.h"
+#include "los_mux.h"
+
+int LOS_VfsInit()
+{
+    if (LOS_MuxCreate(&g_fsMutex) != LOS_OK) {
+        return LOS_NOK;
+    }
+#if (LOSCFG_FS_FATFS == 1)
+    FatFsInit();
+#endif
+
+#if (LOSCFG_FS_LITTLEFS == 1)
+    LfsInit();
+#endif
+    return LOS_OK;
+}
diff --git a/components/fs/vfs/fs_maps.c b/components/fs/vfs/fs_maps.c
new file mode 100644
index 0000000..7c18e29
--- /dev/null
+++ b/components/fs/vfs/fs_maps.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fs_maps.h"
+#include <stdlib.h>
+#include "securec.h"
+#include "los_debug.h"
+#include "los_compiler.h"
+
+struct FsMap *g_fsMap = NULL;
+
+struct FsMap *LOS_FsMapGet(const char *fsType)
+{
+    struct FsMap *curr = g_fsMap;
+
+    (void)VfsLock();
+    while (curr != NULL) {
+        if ((curr->fsType != NULL) && (fsType != NULL) &&
+            (strcmp(curr->fsType, fsType) == 0)) {
+            (void)VfsUnlock();
+            return curr;
+        }
+        curr = curr->next;
+    }
+
+    VfsUnlock();
+    return NULL;
+}
+
+int LOS_FsRegister(const char *fsType, struct MountOps *fsMops,
+        struct FileOps *fsFops, struct FsMgt *fsMgt)
+{
+    if (fsMops == NULL || fsFops == NULL) {
+        return LOS_NOK;
+    }
+
+    (void)VfsLock();
+    struct FsMap *newfs = (struct FsMap *)malloc(sizeof(struct FsMap));
+    if (newfs == NULL) {
+        PRINTK("Fs register malloc failed, fsType %d.\n", fsType);
+        VfsUnlock();
+        return LOS_NOK;
+    }
+    (void)memset_s(newfs, sizeof(struct FsMap), 0, sizeof(struct FsMap));
+
+    newfs->fsType = strdup(fsType);
+    if (newfs->fsType == NULL) {
+        free(newfs);
+        VfsUnlock();
+        return LOS_NOK;
+    }
+
+    newfs->fsMops = fsMops;
+    newfs->fsFops = fsFops;
+    newfs->fsMgt = fsMgt;
+    newfs->fsRefs = 0;
+    newfs->next = g_fsMap;
+    g_fsMap = newfs;
+
+    VfsUnlock();
+    return LOS_OK;
+}
+
+int LOS_FsUnRegister(const char *fsType)
+{
+    struct FsMap *curr = g_fsMap;
+    struct FsMap *prev = NULL;
+
+    (void)VfsLock();
+    while (curr != NULL) {
+        if (curr->fsType == fsType) {
+            break;
+        }
+        prev = curr;
+        curr = curr->next;
+    }
+
+    if (curr == NULL || curr->fsRefs > 0) {
+        /* Not found */
+        VfsUnlock();
+        return LOS_NOK;
+    }
+
+    if (prev == NULL) {
+        /* List head is matched */
+        g_fsMap = curr->next;
+    } else {
+        /* Found in middle of list */
+        prev->next = curr->next;
+    }
+
+    free(curr->fsType);
+    free(curr);
+    VfsUnlock();
+    return LOS_OK;
+}
diff --git a/components/fs/vfs/fs_maps.h b/components/fs/vfs/fs_maps.h
new file mode 100644
index 0000000..7e2484c
--- /dev/null
+++ b/components/fs/vfs/fs_maps.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _FS_MAPS_H_
+#define _FS_MAPS_H_
+
+#include "fs_mount.h"
+#include "fs_operations.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#define FSTYPE_FATFS "vfat"
+
+struct FsMgt {
+    int (*fdisk)(const char *dev, int *lengthArray, int partNum); /* Divide the dev to partitions */
+    int (*format)(const char *partName, void *data); /* Format partition */
+};
+
+struct FsMap {
+    const char *fsType;
+    const struct MountOps *fsMops;
+    const struct FileOps *fsFops;
+    const struct FsMgt *fsMgt;
+    UINT32 fsRefs;
+    struct FsMap *next;
+};
+
+int LOS_FsRegister(const char *fsType, struct MountOps *fsMops,
+        struct FileOps *fsFops, struct FsMgt *fsMgt);
+int LOS_FsUnRegister(const char *fsType);
+struct FsMap *LOS_FsMapGet(const char *fsType);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _FS_MAPS_H_ */
diff --git a/components/fs/vfs/fs_mount.c b/components/fs/vfs/fs_mount.c
new file mode 100644
index 0000000..6855631
--- /dev/null
+++ b/components/fs/vfs/fs_mount.c
@@ -0,0 +1,259 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "fs_mount.h"
+#include "fs_maps.h"
+#include "stdlib.h"
+#include "string.h"
+#include "fs_operations.h"
+#include "los_compiler.h"
+#include "los_debug.h"
+#include "los_mux.h"
+
+struct MountPoint *g_mountPoints = NULL;
+
+/*
+ * path: "/mgy/system"
+ * pathInMp: "/system", for fatfs it's volName in flash
+ *
+ * this function will iterate all mount point, finally parse out the most
+ * suitable "MountPoint" structure.
+ */
+struct MountPoint *LOS_MpFind(const char *path, const char **pathInMp)
+{
+    struct MountPoint *mp = g_mountPoints;
+    struct MountPoint *bestMp = NULL;
+    int bestMatches = 0;
+    if (path == NULL) {
+        return NULL;
+    }
+    if (pathInMp != NULL) {
+        *pathInMp = NULL;
+    }
+    while ((mp != NULL) && (mp->mPath != NULL)) {
+        const char *mPath = mp->mPath;
+        const char *iPath = path;
+        const char *t = NULL;
+        int matches = 0;
+        do {
+            while ((*mPath == '/') && (*(mPath + 1) != '/')) {
+                mPath++;
+            }
+            while ((*iPath == '/') && (*(iPath + 1) != '/')) {
+                iPath++;
+            }
+
+            t = strchr(mPath, '/');
+            if (t == NULL) {
+                t = strchr(mPath, '\0');
+            }
+            if ((t == mPath) || (t == NULL)) {
+                break;
+            }
+            if (strncmp(mPath, iPath, (size_t)(t - mPath)) != 0) {
+                goto next; /* this mount point do not match, check next */
+            }
+
+            iPath += (t - mPath);
+            if ((*iPath != '\0') && (*iPath != '/')) {
+                goto next;
+            }
+
+            matches += (t - mPath);
+            mPath += (t - mPath);
+        } while (*mPath != '\0');
+
+        if (matches > bestMatches) {
+            bestMatches = matches;
+            bestMp = mp;
+
+            while ((*iPath == '/') && (*(iPath + 1) != '/')) {
+                iPath++;
+            }
+
+            if (pathInMp != NULL) {
+                // TODO: temperially change the path in mount
+                //*pathInMp = iPath;
+                *pathInMp = path;
+            }
+        }
+    next:
+        mp = mp->mNext;
+    }
+    return bestMp;
+}
+
+int LOS_FsMount(const char *source, const char *target,
+                const char *fileSystemtype, UINT32 mountFlag,
+                const void *data)
+{
+    struct MountPoint *mp = NULL;
+    const char *pathInMp = NULL;
+
+    /* target must begin with '/', for example /system, /data, etc. */
+    if (target == NULL || target[0] != '/') {
+        return LOS_NOK;
+    }
+
+    /* find mp by target, to see if it was mounted */
+    mp = LOS_MpFind(target, &pathInMp);
+    if (mp != NULL && pathInMp != NULL) {
+        return LOS_NOK;
+    }
+
+    (void)VfsLock();
+    /* Find fsMap coresponding to the fileSystemtype */
+    struct FsMap *mFs = LOS_FsMapGet(fileSystemtype);
+
+    mp = (struct MountPoint *)malloc(sizeof(struct MountPoint));
+    if (mp == NULL) {
+        PRINTK("No memory with mount.\n");
+        VfsUnlock();
+        return LOS_NOK;
+    }
+
+    mp->mFs = mFs;
+    mp->mPath = target;
+    mp->mRefs = 0;
+    if (LOS_MuxCreate(&mp->mMutex) != LOS_OK) {
+        free(mp);
+        VfsUnlock();
+        return LOS_NOK;
+    }
+    mp->mNext = g_mountPoints;
+    mp->mWriteEnable = (mountFlag & MS_RDONLY) ? FALSE : TRUE;
+    g_mountPoints = mp;
+
+    mp->mFs->fsMops->mount(mp, source, mountFlag, data);
+
+    mp->mFs->fsRefs++;
+    VfsUnlock();
+    return LOS_OK;
+}
+
+int LOS_FsUmount(const char *target)
+{
+    struct MountPoint *mp = NULL;
+    struct MountPoint *prev = NULL;
+    const char *pathInMp = NULL;
+    int ret = LOS_NOK;
+
+    if (target == NULL) {
+        return ret;
+    }
+
+    (void)VfsLock();
+    mp = LOS_MpFind(target, &pathInMp);
+    if ((mp == NULL) || (mp->mRefs != 0)) {
+        return ret;
+    }
+
+    if (g_mountPoints == mp) {
+        g_mountPoints = mp->mNext;
+    } else {
+        for (prev = g_mountPoints; prev != NULL; prev = prev->mNext) {
+            if (prev->mNext != mp) {
+                continue;
+            }
+
+            prev->mNext = mp->mNext;
+            break;
+        }
+    }
+
+    mp->mFs->fsMops->umount(mp, target);
+
+    (void)LOS_MuxDelete(mp->mMutex);
+    mp->mFs->fsRefs--;
+    free(mp);
+
+    VfsUnlock();
+    return LOS_OK;
+}
+
+int LOS_FsUmount2(const char *target, int flag)
+{
+    struct MountPoint *mp = NULL;
+    struct MountPoint *prev = NULL;
+    const char *pathInMp = NULL;
+    int ret = LOS_NOK;
+
+    if (target == NULL) {
+        return ret;
+    }
+
+    (void)VfsLock();
+    mp = LOS_MpFind(target, &pathInMp);
+    if ((mp == NULL) || (mp->mRefs != 0)) {
+        return ret;
+    }
+
+    if (g_mountPoints == mp) {
+        g_mountPoints = mp->mNext;
+    } else {
+        for (prev = g_mountPoints; prev != NULL; prev = prev->mNext) {
+            if (prev->mNext != mp) {
+                continue;
+            }
+
+            prev->mNext = mp->mNext;
+            break;
+        }
+    }
+
+    mp->mFs->fsMops->umount2(mp, target, flag);
+
+    (void)LOS_MuxDelete(mp->mMutex);
+    mp->mFs->fsRefs--;
+    free(mp);
+
+    VfsUnlock();
+    return LOS_OK;
+}
+
+
+
+int LOS_MpLock(const struct MountPoint *mp)
+{
+    if (mp == NULL) {
+        return LOS_NOK;
+    }
+
+    return LOS_MuxPend(mp->mMutex, LOS_WAIT_FOREVER);
+}
+
+int LOS_MpUnlock(const struct MountPoint *mp)
+{
+    if (mp == NULL) {
+        return LOS_NOK;
+    }
+
+    return LOS_MuxPost(mp->mMutex);
+}
diff --git a/components/fs/vfs/fs_mount.h b/components/fs/vfs/fs_mount.h
new file mode 100644
index 0000000..2db1cef
--- /dev/null
+++ b/components/fs/vfs/fs_mount.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _FS_MOUNT_H_
+#define _FS_MOUNT_H_
+
+#include "los_compiler.h"
+#include "sys/statfs.h"
+#include "fs_maps.h"
+#include "fs_operations.h"
+//#include "dirent.h"
+//#include "unistd.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+struct MountOps;
+struct MountPoint;
+
+struct MountOps {
+    int (*mount)(struct MountPoint *mp, const char *source,
+            unsigned long mountflags, const void *data);
+    int (*umount)(struct MountPoint *mp, const char* target);
+    int (*umount2)(struct MountPoint *mp, const char* target, int flag);
+    int (*statfs)(const char *path, struct statfs *buf);
+};
+
+struct MountPoint {
+    struct FsMap      *mFs;    /* file system info */
+    struct MountPoint *mNext;  /* point to next mount point */
+    const char        *mPath;  /* target path, etc. /system, /usr */
+    UINT32             mRefs;  /* reference to mount point */
+    UINT32             mMutex; /* mp visit lock */
+    void              *mData;  /* fatfs: fatfs handle from mount */
+    BOOL               mWriteEnable;  /* fatfs: fatfs handle from mount */
+};
+
+extern struct MountPoint *g_mountPoints;
+#define LOS_MP_FOR_EACH_ENTRY(prev) \
+        for (prev = g_mountPoints; prev != NULL; prev = prev->mNext)
+
+int LOS_FsMount(const char *source, const char *target,
+                const char *fileSystemtype, UINT32 mountFlag,
+                const void *data);
+int LOS_FsUmount(const char *target);
+int LOS_FsUmount2(const char *target, int flag);
+struct MountPoint *LOS_MpFind(const char *path, const char **pathInMp);
+int LOS_MpLock(const struct MountPoint *mp);
+int LOS_MpUnlock(const struct MountPoint *mp);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _FS_OPERATIONS_H_ */
diff --git a/components/fs/fs_operations.h b/components/fs/vfs/fs_operations.h
similarity index 60%
rename from components/fs/fs_operations.h
rename to components/fs/vfs/fs_operations.h
index e22be28..5fb4b56 100644
--- a/components/fs/fs_operations.h
+++ b/components/fs/vfs/fs_operations.h
@@ -34,47 +34,31 @@
 
 #include "fcntl.h"
 #include "dirent.h"
+#include "stdint.h"
 #include "unistd.h"
 #include "sys/mount.h"
 #include "sys/stat.h"
 #include "sys/statfs.h"
+#include "los_compiler.h"
 
 #define FS_SUCCESS            0
 #define FS_FAILURE            (-1)
 #define MAX_FILESYSTEM_LEN 2
 
-struct MountOps {
-    int (*Mount)(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags,
-        const void *data);
-    int (*Umount)(const char* target);
-    int (*Umount2)(const char* target, int flag);
-    int (*Statfs)(const char *path, struct statfs *buf);
-};
+#define VFS_ERRNO_SET(err)
+#define set_errno(err)
 
-struct FsMap {
-    const char *fileSystemtype;
-    const struct MountOps *fsMops;
-    const struct FileOps *fsFops;
-};
+typedef enum {
+    FSTYPE_BEGIN,
+    FSTYPE_FATFS,
+    FSTYPE_LITTLEFS,
+    FSTYPE_END
+} LOS_FsType;
 
-struct FileOps {
-    int (*Open)(const char *path, int openFlag, ...);
-    int (*Close)(int fd);
-    int (*Unlink)(const char *fileName);
-    int (*Rmdir)(const char *dirName);
-    int (*Mkdir)(const char *dirName, mode_t mode);
-    struct dirent *(*Readdir)(DIR *dir);
-    DIR *(*Opendir)(const char *dirName);
-    int (*Closedir)(DIR *dir);
-    int (*Read)(int fd, void *buf, size_t len);
-    int (*Write)(int fd, const void *buf, size_t len);
-    off_t (*Seek)(int fd, off_t offset, int whence);
-    int (*Getattr)(const char *path, struct stat *buf);
-    int (*Rename)(const char *oldName, const char *newName);
-    int (*Fsync)(int fd);
-    int (*Fstat)(int fd, struct stat *buf);
-    int (*Stat)(const char *path, struct stat *buf);
-    int (*Ftruncate)(int fd, off_t length);
-};
+extern UINT32 g_fsMutex;
+
+int LOS_VfsInit(void);
+int VfsLock(void);
+void VfsUnlock(void);
 
 #endif /* _FS_OPERATIONS_H_ */
diff --git a/components/fs/vfs/los_fs.h b/components/fs/vfs/los_fs.h
new file mode 100644
index 0000000..d76248c
--- /dev/null
+++ b/components/fs/vfs/los_fs.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * @defgroup los_vfs fs
+ * @ingroup kernel
+ */
+
+#ifndef _LOS_VFS_H_
+#define _LOS_VFS_H_
+
+#include "los_config.h"
+#include "dirent.h"
+#include "sys/mount.h"
+#include "sys/statfs.h"
+#include "sys/stat.h"
+#include "unistd.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+int LOS_Open(const char *path, int flags);
+
+int LOS_Close(int fd);
+
+ssize_t LOS_Read(int fd, char *buff, size_t bytes);
+
+ssize_t LOS_Write(int fd, const void *buf, size_t nbyte);
+
+off_t LOS_Lseek(int fd, off_t offset, int whence);
+
+int LOS_Unlink(const char *path);
+
+int LOS_Fstat(int fd, struct stat *buf);
+
+int LOS_Stat(const char *path, struct stat *buf);
+
+int LOS_Sync(int fd);
+
+int LOS_Mkdir(const char *path, mode_t mode);
+
+DIR *LOS_Opendir(const char *dirName);
+
+struct dirent *LOS_Readdir(DIR *dir);
+
+int LOS_Closedir(DIR *dir);
+
+int LOS_Rename(const char *oldName, const char *newName);
+
+int LOS_Statfs(const char *path, struct statfs *buf);
+
+int LOS_Truncate(int fd, off_t length);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _LOS_FS_H_ */
\ No newline at end of file
diff --git a/components/fs/vfs/partition.c b/components/fs/vfs/partition.c
new file mode 100644
index 0000000..fa6eb05
--- /dev/null
+++ b/components/fs/vfs/partition.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+// #include "fs_operations.h"
+#include "partition.h"
+#include "los_list.h"
+#include "fs_maps.h"
+#include "securec.h"
+#include "stdlib.h"
+#include "string.h"
+
+#define MAX_PARTNAME_LEN 20
+struct Partition *g_partition = NULL;
+
+#if 0
+char * partNameGen(char *devName, int partNum)
+{
+    char *partName = (char *)malloc(sizeof(char) * MAX_PARTNAME_LEN);
+    memset_s(partName, sizeof(char) * MAX_PARTNAME_LEN,
+                    0, sizeof(char) * MAX_PARTNAME_LEN);
+
+    // dev: spinorblk0, partNum: 1, partName will be spinorblk0p0
+    ret = snprintf_s(partName, MAX_PARTNAME_LEN, MAX_PARTNAME_LEN - 1,
+                     "%s%c%u", devName, 'p', partNum);
+}
+#endif
+
+int GetPartIdByPartName(const char *partName)
+{
+#if 0
+    struct Partition *part = LOS_GetPartition(partName);
+    if (part != NULL) {
+        return part->partId;
+    }
+#endif
+    /* TODO: This func should get the PartId from the rule which partname
+     follow, for examle emmcblk0p0 can indicate partId 0 */
+    if (partName == NULL) {
+        return -1;
+    }
+
+    char *p = strrchr(partName, 'p'); /* next charactor to p is the partId */
+    if (p + 1 != 0) {
+        return atoi(p + 1);
+    }
+
+    return -1;
+}
+
+#if 0
+static void PartitionInit(struct Partition *part, char *dev, int partNum, int addr,
+                   int length)
+{
+    part->partName = partNameGen(dev, partNum);
+    part->partId = partNum;
+    part->addr = addr;
+    part->partLen = length;
+    part->formatData = NULL;
+
+    LOS_ListInit(part->partList);
+}
+
+void PartitionAdd(struct Partition *part)
+{
+    if (g_partition == NULL) {
+        g_partition = part;
+        return;
+    }
+
+    LOS_ListTailInsert(&g_partition->partList, part->partList);
+}
+#endif
+
+int LOS_DiskPartition(const char *dev, const char *fsType, int *lengthArray,
+                      int partnum)
+{
+#if 0
+    struct Partition *part = NULL;
+    int addr = 0;
+
+    for (int i = 0; i < partnum; i++) {
+        int partLen = lengthArray[i];
+
+        part = (struct Partition *)malloc(sizeof(struct Partition));
+        PartitionInit(part, dev, i, addr, length);
+        PartitionAdd(part);
+
+        // calc next addr
+        addr += lengthArray[i];
+    }
+#endif
+
+    int ret = LOS_NOK;
+    /* Emmc device take fatfs f_disk() to divides a physical drive */
+    struct FsMap *fMap = LOS_FsMapGet(fsType);
+    if (fMap != NULL && fMap->fsMgt->fdisk != NULL) {
+        ret = fMap->fsMgt->fdisk(dev, lengthArray, partnum);
+    }
+
+    return ret;
+}
+
+#if 0
+int LOS_DeletePartition(const char *partName)
+{
+    struct Partition *part = NULL;
+
+    LOS_DL_LIST_FOR_EACH_ENTRY(part, &g_partition->partList, struct Partition, partList) {
+        if (strcmp(partName, part->partName) == 0) {
+            LOS_ListDelete(&part->partList);
+            free(part->partName);
+            free(part);
+        }
+    }
+}
+#endif
+
+int LOS_PartitionFormat(const char *partName, char *fsType, void *data)
+{
+#if 0
+    struct Partition *part = NULL;
+
+    LOS_DL_LIST_FOR_EACH_ENTRY(part, &g_partition->partList, struct Partition,
+            partList) {
+        if (strcmp(partName, part->partName) == 0) {
+            break;
+        }
+    }
+
+    if (fsType == FSTYPE_LITTLEFS) {
+        struct PartitionCfg *lfsCfg =
+            (struct PartitionCfg *)malloc(sizeof(struct PartitionCfg));
+        memcpy_s(lfsCfg, sizeof(struct PartitionCfg),
+                 (struct PartitionCfg *)data, sizeof(struct PartitionCfg));
+        part->data = lfsCfg;
+    } else if (fsType == FSTYPE_FATFS) {
+        int *formatType = (int *)malloc(sizeof(int));
+        *formatType = *(int *)data;
+        part->data = formatType;
+    }
+#endif
+    int ret = LOS_NOK;
+
+    /* Emmc device take fatfs f_disk() to divides a physical drive */
+    struct FsMap *fMap = LOS_FsMapGet(fsType);
+    if (fMap != NULL && fMap->fsMgt->format != NULL) {
+        ret = fMap->fsMgt->format(partName, data);
+    }
+    return ret;
+}
+
+#if 0
+struct Partition* LOS_GetPartition(const char *partName)
+{
+    struct Partition *part = NULL;
+
+    LOS_DL_LIST_FOR_EACH_ENTRY(part, &g_partition->partList, struct Partition, partList) {
+        if (strcmp(partName, part->partName) == 0) {
+            return part;
+        }
+    }
+    return NULL;
+}
+#endif
diff --git a/components/fs/vfs/partition.h b/components/fs/vfs/partition.h
new file mode 100644
index 0000000..c2f9e2f
--- /dev/null
+++ b/components/fs/vfs/partition.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _PARTITION_H_
+#define _PARTITION_H_
+
+#include "fs_maps.h"
+//#include "fcntl.h"
+//#include "dirent.h"
+//#include "unistd.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+struct Partition {
+    char *partName;
+    int partId;
+    int addr;
+    int partLen;
+    void *formatData;
+};
+
+int LOS_DiskPartition(const char *dev, const char *fsType, int *lengthArray,
+                      int partnum);
+int LOS_PartitionFormat(const char *partName, char *fsType, void *data);
+int GetPartIdByPartName(const char *partName);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __cplusplus */
+
+#endif /* _PARTITION_H_ */
diff --git a/components/fs/vfs_config.h b/components/fs/vfs/vfs_config.h
similarity index 61%
rename from components/fs/vfs_config.h
rename to components/fs/vfs/vfs_config.h
index 95b382b..49337f9 100644
--- a/components/fs/vfs_config.h
+++ b/components/fs/vfs/vfs_config.h
@@ -33,63 +33,8 @@
 #define _VFS_CONFIG_H_
 
 #define PATH_MAX 256
-#define CONFIG_DISABLE_MQUEUE   // disable posix mqueue inode configure
-
-/* file system configur */
-
-#define CONFIG_FS_WRITABLE      // enable file system can be written
-#define CONFIG_FS_READABLE      // enable file system can be read
-#define CONFIG_DEBUG_FS         // enable vfs debug function
-
-
-/* fatfs cache configur */
-/* config block size for fat file system, only can be 0,32,64,128,256,512,1024 */
-#define CONFIG_FS_FAT_SECTOR_PER_BLOCK  64
-
-/* config block num for fat file system */
-#define CONFIG_FS_FAT_READ_NUMS         7
-#define CONFIG_FS_FAT_BLOCK_NUMS        28
-
-#ifdef LOSCFG_FS_FAT_CACHE_SYNC_THREAD
-
-/* config the priority of sync task */
-
-#define CONFIG_FS_FAT_SYNC_THREAD_PRIO 10
-
-/* config dirty ratio of bcache for fat file system */
-
-#define CONFIG_FS_FAT_DIRTY_RATIO      60
-
-/* config time interval of sync thread for fat file system, in milliseconds */
-
-#define CONFIG_FS_FAT_SYNC_INTERVAL    5000
-#endif
-
-#define CONFIG_FS_FLASH_BLOCK_NUM 1
-
-#define CONFIG_FS_MAX_LNK_CNT 40
-
-/* nfs configure */
-
-#define CONFIG_NFS_MACHINE_NAME "IPC"   // nfs device name is IPC
-#define CONFIG_NFS_MACHINE_NAME_SIZE 3  // size of nfs machine name
-
-
-/* file descriptors configure */
-
-#define CONFIG_NFILE_STREAMS        1   // enable file stream
-#define CONFIG_STDIO_BUFFER_SIZE    0
-#define CONFIG_NUNGET_CHARS         0
-#define MIN_START_FD 3 // 0,1,2 are used for stdin,stdout,stderr respectively
-
-#define FD_SET_TOTAL_SIZE               (FD_SETSIZE + CONFIG_NEXPANED_DESCRIPTORS)
-#define FD_SETSIZE                      (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)
-#define CONFIG_NEXPANED_DESCRIPTORS     (CONFIG_NTIME_DESCRIPTORS + CONFIG_NQUEUE_DESCRIPTORS)
-#define TIMER_FD_OFFSET                 FD_SETSIZE
-#define MQUEUE_FD_OFFSET                (FD_SETSIZE + CONFIG_NTIME_DESCRIPTORS)
 
 /* net configure */
-
 #ifdef LOSCFG_NET_LWIP_SACK             // enable socket and net function
 #include "lwip/lwipopts.h"
 #define CONFIG_NSOCKET_DESCRIPTORS  LWIP_CONFIG_NUM_SOCKETS  // max numbers of socket descriptor
@@ -105,7 +50,7 @@
 
 #ifdef LOSCFG_FS_FAT
 #include "fatfs.h"
-#define __FAT_NFILE FAT_MAX_OPEN_FILES
+#define __FAT_NFILE FAT_FS_MAX_OPEN_FILESl
 #else
 #define __FAT_NFILE 0
 #endif
@@ -118,8 +63,10 @@
 #endif
 
 #define CONFIG_NFILE_DESCRIPTORS    (__FAT_NFILE + __LFS_NFILE)
+#define CONFIG_NEXPANED_DESCRIPTORS     (CONFIG_NTIME_DESCRIPTORS + CONFIG_NQUEUE_DESCRIPTORS)
+#define FD_SET_TOTAL_SIZE               (FD_SETSIZE + CONFIG_NEXPANED_DESCRIPTORS)
 
-#define NR_OPEN_DEFAULT CONFIG_NFILE_DESCRIPTORS
+#define FD_SETSIZE                      (CONFIG_NFILE_DESCRIPTORS + CONFIG_NSOCKET_DESCRIPTORS)
 
 /* time configure */
 
@@ -131,12 +78,4 @@
 
 /* directory configure */
 
-#define VFS_USING_WORKDIR               // enable current working directory
-
-/* permission configure */
-#define DEFAULT_DIR_MODE        0777
-#define DEFAULT_FILE_MODE       0666
-
-#define MAX_DIRENT_NUM 14 // 14 means 4096 length buffer can store 14 dirent, see struct DIR
-
 #endif
diff --git a/components/net/lwip-2.1/porting/include/arch/cc.h b/components/net/lwip-2.1/porting/include/arch/cc.h
index 0946270..2b8faf9 100644
--- a/components/net/lwip-2.1/porting/include/arch/cc.h
+++ b/components/net/lwip-2.1/porting/include/arch/cc.h
@@ -106,8 +106,4 @@ extern void LwipLogPrintf(const char *fmt, ...);
 #define init_waitqueue_head(...)
 #define poll_check_waiters(...)
 
-#ifndef _BSD_SOURCE
-#define _BSD_SOURCE 1
-#endif
-
 #endif /* _LWIP_PORTING_CC_H_ */
diff --git a/components/net/lwip-2.1/porting/src/sockets_porting.c b/components/net/lwip-2.1/porting/src/sockets_porting.c
index 05c717e..daae472 100644
--- a/components/net/lwip-2.1/porting/src/sockets_porting.c
+++ b/components/net/lwip-2.1/porting/src/sockets_porting.c
@@ -704,7 +704,7 @@ static u8_t lwip_ioctl_impl(const struct lwip_sock *sock, long cmd, void *argp)
 {
     u8_t err = 0;
     struct ifreq *ifr = (struct ifreq *)argp;
-    u8_t is_ipv6 = 0;
+    bool is_ipv6 = 0;
 
     /* allow it only on IPv6 sockets... */
     is_ipv6 = NETCONNTYPE_ISIPV6((unsigned int)(sock->conn->type));
diff --git a/kal/BUILD.gn b/kal/BUILD.gn
index a4153d4..e1e7d66 100644
--- a/kal/BUILD.gn
+++ b/kal/BUILD.gn
@@ -29,16 +29,7 @@
 
 import("//kernel/liteos_m/liteos.gni")
 
-group("kal") {
-  deps = [ "cmsis" ]
-  deps += [ "posix" ]
-  deps += [ "libsec" ]
-}
-
-config("public") {
-  configs = [
-    "cmsis:public",
-    "posix:public",
-    "libsec:public",
-  ]
+module_name = get_path_info(rebase_path("."), "name")
+module_group(module_name) {
+  modules = [ "cmsis", "libc", "libsec", "posix" ]
 }
diff --git a/kal/Kconfig b/kal/Kconfig
new file mode 100644
index 0000000..ece0fa5
--- /dev/null
+++ b/kal/Kconfig
@@ -0,0 +1,32 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+rsource "cmsis/Kconfig"
+rsource "libc/Kconfig"
+rsource "posix/Kconfig"
\ No newline at end of file
diff --git a/kal/cmsis/Kconfig b/kal/cmsis/Kconfig
new file mode 100644
index 0000000..031d7c7
--- /dev/null
+++ b/kal/cmsis/Kconfig
@@ -0,0 +1,36 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+config KAL_CMSIS
+    bool "Enable KAL CMSIS"
+    default y
+    help
+      Answer Y to enable LiteOS Kernel Abstraction Layer support CMSIS API.
+
+
diff --git a/kal/libc/BUILD.gn b/kal/libc/BUILD.gn
new file mode 100644
index 0000000..36d2488
--- /dev/null
+++ b/kal/libc/BUILD.gn
@@ -0,0 +1,35 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("//kernel/liteos_m/liteos.gni")
+
+module_name = get_path_info(rebase_path("."), "name")
+module_group(module_name) {
+  modules = [ "musl","newlib" ]
+}
\ No newline at end of file
diff --git a/kal/libc/Kconfig b/kal/libc/Kconfig
new file mode 100644
index 0000000..32aa631
--- /dev/null
+++ b/kal/libc/Kconfig
@@ -0,0 +1,44 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+choice
+    prompt "Choose libc implementation"
+    default LIBC_MUSL
+    help
+      Choose libc implementation.
+
+config LIBC_MUSL
+    bool "musl libc"
+
+config LIBC_NEWLIB
+    bool "newlibc"
+
+endchoice
+
+rsource "newlib/Kconfig"
diff --git a/kal/libc/musl/BUILD.gn b/kal/libc/musl/BUILD.gn
new file mode 100644
index 0000000..a36055c
--- /dev/null
+++ b/kal/libc/musl/BUILD.gn
@@ -0,0 +1,46 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("//kernel/liteos_m/liteos.gni")
+
+module_switch = defined(LOSCFG_LIBC_MUSL)
+module_name = get_path_info(rebase_path("."), "name")
+kernel_module(module_name) {
+  sources = [
+    "malloc.c",
+  ]
+
+  if (defined(LOSCFG_LIBC_MUSL_FS)) {
+    sources += [
+      "fs.c",
+    ]
+  }
+
+  public_deps = ["//third_party/musl/porting/liteos_m/kernel"]
+}
diff --git a/kal/libc/musl/Kconfig b/kal/libc/musl/Kconfig
new file mode 100644
index 0000000..a90394d
--- /dev/null
+++ b/kal/libc/musl/Kconfig
@@ -0,0 +1,39 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+if LIBC_MUSL
+
+config LIBC_MUSL_FS
+    bool "Enable POSIX file system API support"
+    default y
+    depends on FS_VFS
+    help
+        This enables POSIX style file system related APIs.
+
+endif # LIBC_MUSL
diff --git a/kal/libc/musl/fs.c b/kal/libc/musl/fs.c
new file mode 100644
index 0000000..527ce66
--- /dev/null
+++ b/kal/libc/musl/fs.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+ * Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_config.h"
+#include "los_fs.h"
+#include "stdarg.h"
+#include "dirent.h"
+#include "sys/mount.h"
+#include "sys/statfs.h"
+#include "sys/stat.h"
+#include "unistd.h"
+
+int mount(const char *source, const char *target,
+              const char *filesystemtype, unsigned long mountflags,
+              const void *data)
+{
+    return LOS_Mount(source, target, filesystemtype, mountflags, data);
+}
+
+int umount(const char *target)
+{
+    return LOS_Umount(target);
+}
+
+int umount2(const char *target, int flag)
+{
+    return LOS_Umount2(target, flag);
+}
+
+int open(const char *path, int oflag, ...)
+{
+    va_list vaList;
+    va_start(vaList, oflag);
+    int ret;
+    ret = LOS_Open(path, oflag, vaList);
+    va_end(vaList);
+    return ret;
+}
+
+int close(int fd)
+{
+    return LOS_Close(fd);
+}
+
+ssize_t read(int fd, void *buf, size_t nbyte)
+{
+    return LOS_Read(fd, buf, nbyte);
+}
+
+ssize_t write(int fd, const void *buf, size_t nbyte)
+{
+    return LOS_Write(fd, buf, nbyte);
+}
+
+off_t lseek(int fd, off_t offset, int whence)
+{
+    return LOS_Lseek(fd, offset, whence);
+}
+
+int unlink(const char *path)
+{
+    return LOS_Unlink(path);
+}
+
+int fstat(int fd, struct stat *buf)
+{
+    return LOS_Fstat(fd, buf);
+}
+
+int stat(const char *path, struct stat *buf)
+{
+    return LOS_Stat(path, buf);
+}
+
+int fsync(int fd)
+{
+    return LOS_Sync(fd);
+}
+
+int mkdir(const char *path, mode_t mode)
+{
+    return LOS_Mkdir(path, mode);
+}
+
+DIR *opendir(const char *dirName)
+{
+    return LOS_Opendir(dirName);
+}
+
+struct dirent *readdir(DIR *dir)
+{
+    return LOS_Readdir(dir);
+}
+
+int closedir(DIR *dir)
+{
+    return LOS_Closedir(dir);
+}
+
+int rmdir(const char *path)
+{
+    return LOS_Unlink(path);
+}
+
+int rename(const char *oldName, const char *newName)
+{
+    return LOS_Rename(oldName, newName);
+}
+
+int statfs(const char *path, struct statfs *buf)
+{
+    return LOS_Statfs(path, buf);
+}
+
+int ftruncate(int fd, off_t length)
+{
+    return LOS_Ftruncate(fd, length);
+}
diff --git a/kal/posix/src/malloc.c b/kal/libc/musl/malloc.c
similarity index 97%
rename from kal/posix/src/malloc.c
rename to kal/libc/musl/malloc.c
index c206238..434cba0 100644
--- a/kal/posix/src/malloc.c
+++ b/kal/libc/musl/malloc.c
@@ -27,83 +27,83 @@
  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "securec.h"
-#include "los_config.h"
-#include "los_memory.h"
-
-
-void *calloc(size_t nitems, size_t size)
-{
-    size_t real_size;
-    void *ptr = NULL;
-
-    if (nitems == 0 || size == 0) {
-        return NULL;
-    }
-
-    real_size = (size_t)(nitems * size);
-    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, real_size);
-    if (ptr != NULL) {
-        (void)memset_s(ptr, real_size, 0, real_size);
-    }
-    return ptr;
-}
-
-void free(void *ptr)
-{
-    if (ptr == NULL) {
-        return;
-    }
-
-    LOS_MemFree(OS_SYS_MEM_ADDR, ptr);
-}
-
-void *malloc(size_t size)
-{
-    if (size == 0) {
-        return NULL;
-    }
-
-    return LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
-}
-
-void *zalloc(size_t size)
-{
-    void *ptr = NULL;
-
-    if (size == 0) {
-        return NULL;
-    }
-
-    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
-    if (ptr != NULL) {
-        (void)memset_s(ptr, size, 0, size);
-    }
-    return ptr;
-}
-
-void *memalign(size_t boundary, size_t size)
-{
-    if (size == 0) {
-        return NULL;
-    }
-
-    return LOS_MemAllocAlign(OS_SYS_MEM_ADDR, size, boundary);
-}
-
-void *realloc(void *ptr, size_t size)
-{
-    if (ptr == NULL) {
-        return malloc(size);
-    }
-
-    if (size == 0) {
-        free(ptr);
-        return NULL;
-    }
-
-    return LOS_MemRealloc(OS_SYS_MEM_ADDR, ptr, size);
-}
-
+ */
+
+#include "securec.h"
+#include "los_config.h"
+#include "los_memory.h"
+
+
+void *calloc(size_t nitems, size_t size)
+{
+    size_t real_size;
+    void *ptr = NULL;
+
+    if (nitems == 0 || size == 0) {
+        return NULL;
+    }
+
+    real_size = (size_t)(nitems * size);
+    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, real_size);
+    if (ptr != NULL) {
+        (void)memset_s(ptr, real_size, 0, real_size);
+    }
+    return ptr;
+}
+
+void free(void *ptr)
+{
+    if (ptr == NULL) {
+        return;
+    }
+
+    LOS_MemFree(OS_SYS_MEM_ADDR, ptr);
+}
+
+void *malloc(size_t size)
+{
+    if (size == 0) {
+        return NULL;
+    }
+
+    return LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
+}
+
+void *zalloc(size_t size)
+{
+    void *ptr = NULL;
+
+    if (size == 0) {
+        return NULL;
+    }
+
+    ptr = LOS_MemAlloc(OS_SYS_MEM_ADDR, size);
+    if (ptr != NULL) {
+        (void)memset_s(ptr, size, 0, size);
+    }
+    return ptr;
+}
+
+void *memalign(size_t boundary, size_t size)
+{
+    if (size == 0) {
+        return NULL;
+    }
+
+    return LOS_MemAllocAlign(OS_SYS_MEM_ADDR, size, boundary);
+}
+
+void *realloc(void *ptr, size_t size)
+{
+    if (ptr == NULL) {
+        return malloc(size);
+    }
+
+    if (size == 0) {
+        free(ptr);
+        return NULL;
+    }
+
+    return LOS_MemRealloc(OS_SYS_MEM_ADDR, ptr, size);
+}
+
diff --git a/kal/libc/newlib/BUILD.gn b/kal/libc/newlib/BUILD.gn
new file mode 100644
index 0000000..1a86947
--- /dev/null
+++ b/kal/libc/newlib/BUILD.gn
@@ -0,0 +1,56 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+import("//kernel/liteos_m/liteos.gni")
+
+module_switch = defined(LOSCFG_LIBC_NEWLIB)
+module_name = get_path_info(rebase_path("."), "name")
+kernel_module(module_name) {
+  sources = [
+    "porting/src/other_adapt.c",
+    "porting/src/time_adapt.c",
+  ]
+
+  if (defined(LOSCFG_LIBC_NEWLIB_FS)) {
+    sources += [
+      "porting/src/fs_adapt.c",
+      "//third_party/musl/porting/liteos_m/kernel/src/misc/realpath.c",
+    ]
+  }
+}
+
+config("public") {
+  include_dirs = [
+    "porting/include",
+  ]
+
+  cflags = [
+    "-DLOSCFG_PATH_MAX=1111",
+  ]
+}
diff --git a/kal/libc/newlib/Kconfig b/kal/libc/newlib/Kconfig
new file mode 100644
index 0000000..3f3e92f
--- /dev/null
+++ b/kal/libc/newlib/Kconfig
@@ -0,0 +1,39 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+if LIBC_NEWLIB
+
+config LIBC_NEWLIB_FS
+    bool "Enable POSIX file system API support"
+    default y
+    depends on FS_VFS
+    help
+        This enables POSIX style file system related APIs.
+
+endif # LIBC_NEWLIB
diff --git a/kal/libc/newlib/porting/include/dirent.h b/kal/libc/newlib/porting/include/dirent.h
new file mode 100644
index 0000000..ba997da
--- /dev/null
+++ b/kal/libc/newlib/porting/include/dirent.h
@@ -0,0 +1,56 @@
+#ifndef _ADAPT_DIRENT_H
+#define _ADAPT_DIRENT_H
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct dirent {
+    ino_t d_ino;
+    off_t d_off;
+    unsigned short d_reclen;
+    unsigned char d_type;
+    char d_name[256];
+};
+
+typedef struct __dirstream DIR;
+
+#define d_fileno d_ino
+
+int            closedir(DIR *);
+DIR           *fdopendir(int);
+DIR           *opendir(const char *);
+struct dirent *readdir(DIR *);
+int            readdir_r(DIR *__restrict, struct dirent *__restrict, struct dirent **__restrict);
+void           rewinddir(DIR *);
+int            dirfd(DIR *);
+
+int scandir(const char *, struct dirent ***, int (*)(const struct dirent *), int (*)(const struct dirent **, const struct dirent **));
+
+#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+void           seekdir(DIR *, long);
+long           telldir(DIR *);
+#endif
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+#define DT_UNKNOWN 0
+#define DT_FIFO 1
+#define DT_CHR 2
+#define DT_DIR 4
+#define DT_BLK 6
+#define DT_REG 8
+#define DT_LNK 10
+#define DT_SOCK 12
+#define DT_WHT 14
+#define IFTODT(x) ((x)>>12 & 017)
+#define DTTOIF(x) ((x)<<12)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ADAPT_DIRENT_H */
diff --git a/kal/libc/newlib/porting/include/dlfcn.h b/kal/libc/newlib/porting/include/dlfcn.h
new file mode 100644
index 0000000..cace960
--- /dev/null
+++ b/kal/libc/newlib/porting/include/dlfcn.h
@@ -0,0 +1,42 @@
+#ifndef _ADAPT_DLFCN_H
+#define _ADAPT_DLFCN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/features.h>
+#if 0
+#define RTLD_LAZY   1
+#define RTLD_NOW    2
+#define RTLD_NOLOAD 4
+#define RTLD_NODELETE 4096
+#define RTLD_GLOBAL 256
+#define RTLD_LOCAL  0
+
+#define RTLD_NEXT    ((void *)-1)
+#define RTLD_DEFAULT ((void *)0)
+
+#define RTLD_DI_LINKMAP 2
+
+int    dlclose(void *);
+char  *dlerror(void);
+void  *dlopen(const char *, int);
+void  *dlsym(void *__restrict, const char *__restrict);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+typedef struct {
+	const char *dli_fname;
+	void *dli_fbase;
+	const char *dli_sname;
+	void *dli_saddr;
+} Dl_info;
+int dladdr(const void *, Dl_info *);
+int dlinfo(void *, int, void *);
+#endif
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ADAPT_DLFCN_H */
diff --git a/kal/libc/newlib/porting/include/endian.h b/kal/libc/newlib/porting/include/endian.h
new file mode 100644
index 0000000..f501c4b
--- /dev/null
+++ b/kal/libc/newlib/porting/include/endian.h
@@ -0,0 +1,10 @@
+//
+// Created by simonli on 11/23/21.
+//
+
+#ifndef _ADAPT_ENDIAN_H
+#define _ADAPT_ENDIAN_H
+
+#include_next <machine/endian.h>
+
+#endif //_ADAPT_ENDIAN_H
diff --git a/kal/libc/newlib/porting/include/limits.h b/kal/libc/newlib/porting/include/limits.h
new file mode 100644
index 0000000..9ad38cf
--- /dev/null
+++ b/kal/libc/newlib/porting/include/limits.h
@@ -0,0 +1,13 @@
+//
+// Created by simonli on 11/23/21.
+//
+
+#ifndef _ADAPT_LIMITS_H
+#define _ADAPT_LIMITS_H
+
+#include_next <limits.h>
+
+#define SSIZE_MAX   LONG_MAX
+#undef PATH_MAX
+#define PATH_MAX    LOSCFG_PATH_MAX
+#endif //_ADAPT_LIMITS_H
diff --git a/kal/libc/newlib/porting/include/mqueue.h b/kal/libc/newlib/porting/include/mqueue.h
new file mode 100644
index 0000000..d1a628e
--- /dev/null
+++ b/kal/libc/newlib/porting/include/mqueue.h
@@ -0,0 +1,35 @@
+#ifndef _ADAPT_MQUEUE_H
+#define _ADAPT_MQUEUE_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "sys/features.h"
+#include <sys/types.h>
+
+typedef int mqd_t;
+struct mq_attr {
+	long mq_flags, mq_maxmsg, mq_msgsize, mq_curmsgs, __unused[4];
+};
+struct sigevent;
+
+int mq_close(mqd_t);
+int mq_getattr(mqd_t, struct mq_attr *);
+int mq_notify(mqd_t, const struct sigevent *);
+mqd_t mq_open(const char *, int, ...);
+ssize_t mq_receive(mqd_t, char *, size_t, unsigned *);
+int mq_send(mqd_t, const char *, size_t, unsigned);
+int mq_setattr(mqd_t, const struct mq_attr *__restrict, struct mq_attr *__restrict);
+ssize_t mq_timedreceive(mqd_t, char *__restrict, size_t, unsigned *__restrict, const struct timespec *__restrict);
+int mq_timedsend(mqd_t, const char *, size_t, unsigned, const struct timespec *);
+int mq_unlink(const char *);
+
+#if _REDIR_TIME64
+__REDIR(mq_timedreceive, __mq_timedreceive_time64);
+__REDIR(mq_timedsend, __mq_timedsend_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/kal/libc/newlib/porting/include/net/if.h b/kal/libc/newlib/porting/include/net/if.h
new file mode 100644
index 0000000..17b1cc7
--- /dev/null
+++ b/kal/libc/newlib/porting/include/net/if.h
@@ -0,0 +1,142 @@
+//
+// Created by simonli on 11/23/21.
+//
+
+#ifndef _ADAPT_IF_H
+#define _ADAPT_IF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "sys/features.h"
+
+#define IF_NAMESIZE 16
+
+struct if_nameindex {
+    unsigned int if_index;
+    char *if_name;
+};
+
+unsigned int if_nametoindex (const char *);
+char *if_indextoname (unsigned int, char *);
+struct if_nameindex *if_nameindex (void);
+void if_freenameindex (struct if_nameindex *);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#include <sys/socket.h>
+
+#define IFF_UP  0x1
+#define IFF_BROADCAST 0x2
+#define IFF_DEBUG 0x4
+#define IFF_LOOPBACK 0x8
+#define IFF_POINTOPOINT 0x10
+#define IFF_NOTRAILERS 0x20
+#define IFF_RUNNING 0x40
+#define IFF_NOARP 0x80
+#define IFF_PROMISC 0x100
+#define IFF_ALLMULTI 0x200
+#define IFF_MASTER 0x400
+#define IFF_SLAVE 0x800
+#define IFF_MULTICAST 0x1000
+#define IFF_PORTSEL 0x2000
+#define IFF_AUTOMEDIA 0x4000
+#define IFF_DYNAMIC 0x8000
+#define IFF_LOWER_UP 0x10000
+#define IFF_DORMANT 0x20000
+#define IFF_ECHO 0x40000
+#define IFF_VOLATILE (IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST| \
+        IFF_ECHO|IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
+
+struct ifaddr {
+        struct sockaddr ifa_addr;
+        union {
+                struct sockaddr ifu_broadaddr;
+                struct sockaddr ifu_dstaddr;
+        } ifa_ifu;
+        struct iface *ifa_ifp;
+        struct ifaddr *ifa_next;
+};
+
+#define ifa_broadaddr   ifa_ifu.ifu_broadaddr
+#define ifa_dstaddr     ifa_ifu.ifu_dstaddr
+
+struct ifmap {
+        unsigned long int mem_start;
+        unsigned long int mem_end;
+        unsigned short int base_addr;
+        unsigned char irq;
+        unsigned char dma;
+        unsigned char port;
+};
+
+#define IFHWADDRLEN     6
+#define IFNAMSIZ        IF_NAMESIZE
+
+struct ifreq {
+        union {
+                char ifrn_name[IFNAMSIZ];
+        } ifr_ifrn;
+        union {
+                struct sockaddr ifru_addr;
+                struct sockaddr ifru_dstaddr;
+                struct sockaddr ifru_broadaddr;
+                struct sockaddr ifru_netmask;
+                struct sockaddr ifru_hwaddr;
+                short int ifru_flags;
+                int ifru_ivalue;
+                int ifru_mtu;
+                struct ifmap ifru_map;
+                char ifru_slave[IFNAMSIZ];
+                char ifru_newname[IFNAMSIZ];
+                char *ifru_data;
+        } ifr_ifru;
+};
+
+#define ifr_name        ifr_ifrn.ifrn_name
+#define ifr_hwaddr      ifr_ifru.ifru_hwaddr
+#define ifr_addr        ifr_ifru.ifru_addr
+#define ifr_dstaddr     ifr_ifru.ifru_dstaddr
+#define ifr_broadaddr   ifr_ifru.ifru_broadaddr
+#define ifr_netmask     ifr_ifru.ifru_netmask
+#define ifr_flags       ifr_ifru.ifru_flags
+#define ifr_metric      ifr_ifru.ifru_ivalue
+#define ifr_mtu         ifr_ifru.ifru_mtu
+#define ifr_map         ifr_ifru.ifru_map
+#define ifr_slave       ifr_ifru.ifru_slave
+#define ifr_data        ifr_ifru.ifru_data
+#define ifr_ifindex     ifr_ifru.ifru_ivalue
+#define ifr_bandwidth   ifr_ifru.ifru_ivalue
+#define ifr_qlen        ifr_ifru.ifru_ivalue
+#define ifr_newname     ifr_ifru.ifru_newname
+#define _IOT_ifreq      _IOT(_IOTS(char),IFNAMSIZ,_IOTS(char),16,0,0)
+#define _IOT_ifreq_short _IOT(_IOTS(char),IFNAMSIZ,_IOTS(short),1,0,0)
+#define _IOT_ifreq_int  _IOT(_IOTS(char),IFNAMSIZ,_IOTS(int),1,0,0)
+
+struct ifconf {
+        int ifc_len;
+        union {
+                char *ifcu_buf;
+                struct ifreq *ifcu_req;
+        } ifc_ifcu;
+};
+
+#define ifc_buf         ifc_ifcu.ifcu_buf
+#define ifc_req         ifc_ifcu.ifcu_req
+#define _IOT_ifconf _IOT(_IOTS(struct ifconf),1,0,0,0,0)
+
+#define __UAPI_DEF_IF_IFCONF                                    0
+#define __UAPI_DEF_IF_IFMAP                                     0
+#define __UAPI_DEF_IF_IFNAMSIZ                                  0
+#define __UAPI_DEF_IF_IFREQ                                     0
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS                          0
+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO    0
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif //_ADAPT_IF_H
diff --git a/kal/libc/newlib/porting/include/netinet/in.h b/kal/libc/newlib/porting/include/netinet/in.h
new file mode 100644
index 0000000..d0484d7
--- /dev/null
+++ b/kal/libc/newlib/porting/include/netinet/in.h
@@ -0,0 +1,415 @@
+#ifndef	_NETINET_IN_H
+#define	_NETINET_IN_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "sys/features.h"
+#include <inttypes.h>
+#include <sys/socket.h>
+
+typedef uint16_t in_port_t;
+typedef uint32_t in_addr_t;
+struct in_addr { in_addr_t s_addr; };
+
+struct sockaddr_in {
+	sa_family_t sin_family;
+	in_port_t sin_port;
+	struct in_addr sin_addr;
+	uint8_t sin_zero[8];
+};
+
+struct in6_addr {
+	union {
+		uint8_t __s6_addr[16];
+		uint16_t __s6_addr16[8];
+		uint32_t __s6_addr32[4];
+	} __in6_union;
+};
+#define s6_addr __in6_union.__s6_addr
+#define s6_addr16 __in6_union.__s6_addr16
+#define s6_addr32 __in6_union.__s6_addr32
+
+struct sockaddr_in6 {
+	sa_family_t     sin6_family;
+	in_port_t       sin6_port;
+	uint32_t        sin6_flowinfo;
+	struct in6_addr sin6_addr;
+	uint32_t        sin6_scope_id;
+};
+
+struct ipv6_mreq {
+	struct in6_addr ipv6mr_multiaddr;
+	unsigned        ipv6mr_interface;
+};
+
+#define INADDR_ANY        ((in_addr_t) 0x00000000)
+#define INADDR_BROADCAST  ((in_addr_t) 0xffffffff)
+#define INADDR_NONE       ((in_addr_t) 0xffffffff)
+#define INADDR_LOOPBACK   ((in_addr_t) 0x7f000001)
+
+#define INADDR_UNSPEC_GROUP     ((in_addr_t) 0xe0000000)
+#define INADDR_ALLHOSTS_GROUP   ((in_addr_t) 0xe0000001)
+#define INADDR_ALLRTRS_GROUP    ((in_addr_t) 0xe0000002)
+#define INADDR_ALLSNOOPERS_GROUP ((in_addr_t) 0xe000006a)
+#define INADDR_MAX_LOCAL_GROUP  ((in_addr_t) 0xe00000ff)
+
+#define IN6ADDR_ANY_INIT      { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }
+#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }
+
+extern const struct in6_addr in6addr_any, in6addr_loopback;
+
+#undef INET_ADDRSTRLEN
+#undef INET6_ADDRSTRLEN
+#define INET_ADDRSTRLEN  16
+#define INET6_ADDRSTRLEN 46
+
+uint32_t htonl(uint32_t);
+uint16_t htons(uint16_t);
+uint32_t ntohl(uint32_t);
+uint16_t ntohs(uint16_t);
+
+#define IPPORT_RESERVED 1024
+
+#define IPPROTO_IP       0
+#define IPPROTO_HOPOPTS  0
+#define IPPROTO_ICMP     1
+#define IPPROTO_IGMP     2
+#define IPPROTO_IPIP     4
+#define IPPROTO_TCP      6
+#define IPPROTO_EGP      8
+#define IPPROTO_PUP      12
+#define IPPROTO_UDP      17
+#define IPPROTO_IDP      22
+#define IPPROTO_TP       29
+#define IPPROTO_DCCP     33
+#define IPPROTO_IPV6     41
+#define IPPROTO_ROUTING  43
+#define IPPROTO_FRAGMENT 44
+#define IPPROTO_RSVP     46
+#define IPPROTO_GRE      47
+#define IPPROTO_ESP      50
+#define IPPROTO_AH       51
+#define IPPROTO_ICMPV6   58
+#define IPPROTO_NONE     59
+#define IPPROTO_DSTOPTS  60
+#define IPPROTO_MTP      92
+#define IPPROTO_BEETPH   94
+#define IPPROTO_ENCAP    98
+#define IPPROTO_PIM      103
+#define IPPROTO_COMP     108
+#define IPPROTO_SCTP     132
+#define IPPROTO_MH       135
+#define IPPROTO_UDPLITE  136
+#define IPPROTO_MPLS     137
+#define IPPROTO_RAW      255
+#define IPPROTO_MAX      256
+
+#define IN6_IS_ADDR_UNSPECIFIED(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint32_t *) (a))[2] == 0 && ((uint32_t *) (a))[3] == 0)
+
+#define IN6_IS_ADDR_LOOPBACK(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint32_t *) (a))[2] == 0 && \
+         ((uint8_t *) (a))[12] == 0 && ((uint8_t *) (a))[13] == 0 && \
+         ((uint8_t *) (a))[14] == 0 && ((uint8_t *) (a))[15] == 1 )
+
+#define IN6_IS_ADDR_MULTICAST(a) (((uint8_t *) (a))[0] == 0xff)
+
+#define IN6_IS_ADDR_LINKLOCAL(a) \
+        ((((uint8_t *) (a))[0]) == 0xfe && (((uint8_t *) (a))[1] & 0xc0) == 0x80)
+
+#define IN6_IS_ADDR_SITELOCAL(a) \
+        ((((uint8_t *) (a))[0]) == 0xfe && (((uint8_t *) (a))[1] & 0xc0) == 0xc0)
+
+#define IN6_IS_ADDR_V4MAPPED(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint8_t *) (a))[8] == 0 && ((uint8_t *) (a))[9] == 0 && \
+         ((uint8_t *) (a))[10] == 0xff && ((uint8_t *) (a))[11] == 0xff)
+
+#define IN6_IS_ADDR_V4COMPAT(a) \
+        (((uint32_t *) (a))[0] == 0 && ((uint32_t *) (a))[1] == 0 && \
+         ((uint32_t *) (a))[2] == 0 && ((uint8_t *) (a))[15] > 1)
+
+#define IN6_IS_ADDR_MC_NODELOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x1))
+
+#define IN6_IS_ADDR_MC_LINKLOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x2))
+
+#define IN6_IS_ADDR_MC_SITELOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x5))
+
+#define IN6_IS_ADDR_MC_ORGLOCAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0x8))
+
+#define IN6_IS_ADDR_MC_GLOBAL(a) \
+        (IN6_IS_ADDR_MULTICAST(a) && ((((uint8_t *) (a))[1] & 0xf) == 0xe))
+
+#define __ARE_4_EQUAL(a,b) \
+	(!( (0[a]-0[b]) | (1[a]-1[b]) | (2[a]-2[b]) | (3[a]-3[b]) ))
+#define IN6_ARE_ADDR_EQUAL(a,b) \
+	__ARE_4_EQUAL((const uint32_t *)(a), (const uint32_t *)(b))
+
+#define	IN_CLASSA(a)		((((in_addr_t)(a)) & 0x80000000) == 0)
+#define	IN_CLASSA_NET		0xff000000
+#define	IN_CLASSA_NSHIFT	24
+#define	IN_CLASSA_HOST		(0xffffffff & ~IN_CLASSA_NET)
+#define	IN_CLASSA_MAX		128
+#define	IN_CLASSB(a)		((((in_addr_t)(a)) & 0xc0000000) == 0x80000000)
+#define	IN_CLASSB_NET		0xffff0000
+#define	IN_CLASSB_NSHIFT	16
+#define	IN_CLASSB_HOST		(0xffffffff & ~IN_CLASSB_NET)
+#define	IN_CLASSB_MAX		65536
+#define	IN_CLASSC(a)		((((in_addr_t)(a)) & 0xe0000000) == 0xc0000000)
+#define	IN_CLASSC_NET		0xffffff00
+#define	IN_CLASSC_NSHIFT	8
+#define	IN_CLASSC_HOST		(0xffffffff & ~IN_CLASSC_NET)
+#define	IN_CLASSD(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xe0000000)
+#define	IN_MULTICAST(a)		IN_CLASSD(a)
+#define	IN_EXPERIMENTAL(a)	((((in_addr_t)(a)) & 0xe0000000) == 0xe0000000)
+#define	IN_BADCLASS(a)		((((in_addr_t)(a)) & 0xf0000000) == 0xf0000000)
+
+#define IN_LOOPBACKNET 127
+
+
+#define IP_TOS             1
+#define IP_TTL             2
+#define IP_HDRINCL         3
+#define IP_OPTIONS         4
+#define IP_ROUTER_ALERT    5
+#define IP_RECVOPTS        6
+#define IP_RETOPTS         7
+#define IP_PKTINFO         8
+#define IP_PKTOPTIONS      9
+#define IP_PMTUDISC        10
+#define IP_MTU_DISCOVER    10
+#define IP_RECVERR         11
+#define IP_RECVTTL         12
+#define IP_RECVTOS         13
+#define IP_MTU             14
+#define IP_FREEBIND        15
+#define IP_IPSEC_POLICY    16
+#define IP_XFRM_POLICY     17
+#define IP_PASSSEC         18
+#define IP_TRANSPARENT     19
+#define IP_ORIGDSTADDR     20
+#define IP_RECVORIGDSTADDR IP_ORIGDSTADDR
+#define IP_MINTTL          21
+#define IP_NODEFRAG        22
+#define IP_CHECKSUM        23
+#define IP_BIND_ADDRESS_NO_PORT 24
+#define IP_RECVFRAGSIZE    25
+#define IP_MULTICAST_IF    32
+#define IP_MULTICAST_TTL   33
+#define IP_MULTICAST_LOOP  34
+#define IP_ADD_MEMBERSHIP  35
+#define IP_DROP_MEMBERSHIP 36
+#define IP_UNBLOCK_SOURCE  37
+#define IP_BLOCK_SOURCE    38
+#define IP_ADD_SOURCE_MEMBERSHIP  39
+#define IP_DROP_SOURCE_MEMBERSHIP 40
+#define IP_MSFILTER        41
+#define IP_MULTICAST_ALL   49
+#define IP_UNICAST_IF      50
+
+#define IP_RECVRETOPTS IP_RETOPTS
+
+#define IP_PMTUDISC_DONT   0
+#define IP_PMTUDISC_WANT   1
+#define IP_PMTUDISC_DO     2
+#define IP_PMTUDISC_PROBE  3
+#define IP_PMTUDISC_INTERFACE 4
+#define IP_PMTUDISC_OMIT   5
+
+#define IP_DEFAULT_MULTICAST_TTL        1
+#define IP_DEFAULT_MULTICAST_LOOP       1
+#define IP_MAX_MEMBERSHIPS              20
+
+struct ip_opts {
+	struct in_addr ip_dst;
+	char ip_opts[40];
+};
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+#define MCAST_JOIN_GROUP   42
+#define MCAST_BLOCK_SOURCE 43
+#define MCAST_UNBLOCK_SOURCE      44
+#define MCAST_LEAVE_GROUP  45
+#define MCAST_JOIN_SOURCE_GROUP   46
+#define MCAST_LEAVE_SOURCE_GROUP  47
+#define MCAST_MSFILTER     48
+
+#define MCAST_EXCLUDE 0
+#define MCAST_INCLUDE 1
+
+struct ip_mreq {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_interface;
+};
+
+struct ip_mreqn {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_address;
+	int imr_ifindex;
+};
+
+struct ip_mreq_source {
+	struct in_addr imr_multiaddr;
+	struct in_addr imr_interface;
+	struct in_addr imr_sourceaddr;
+};
+
+struct ip_msfilter {
+	struct in_addr imsf_multiaddr;
+	struct in_addr imsf_interface;
+	uint32_t imsf_fmode;
+	uint32_t imsf_numsrc;
+	struct in_addr imsf_slist[1];
+};
+#define IP_MSFILTER_SIZE(numsrc) \
+	(sizeof(struct ip_msfilter) - sizeof(struct in_addr) \
+	+ (numsrc) * sizeof(struct in_addr))
+
+struct group_req {
+	uint32_t gr_interface;
+	struct sockaddr_storage gr_group;
+};
+
+struct group_source_req {
+	uint32_t gsr_interface;
+	struct sockaddr_storage gsr_group;
+	struct sockaddr_storage gsr_source;
+};
+
+struct group_filter {
+	uint32_t gf_interface;
+	struct sockaddr_storage gf_group;
+	uint32_t gf_fmode;
+	uint32_t gf_numsrc;
+	struct sockaddr_storage gf_slist[1];
+};
+#define GROUP_FILTER_SIZE(numsrc) \
+	(sizeof(struct group_filter) - sizeof(struct sockaddr_storage) \
+	+ (numsrc) * sizeof(struct sockaddr_storage))
+
+struct in_pktinfo {
+	int ipi_ifindex;
+	struct in_addr ipi_spec_dst;
+	struct in_addr ipi_addr;
+};
+
+struct in6_pktinfo {
+	struct in6_addr ipi6_addr;
+	unsigned ipi6_ifindex;
+};
+
+struct ip6_mtuinfo {
+	struct sockaddr_in6 ip6m_addr;
+	uint32_t ip6m_mtu;
+};
+#endif
+
+#define IPV6_ADDRFORM           1
+#define IPV6_2292PKTINFO        2
+#define IPV6_2292HOPOPTS        3
+#define IPV6_2292DSTOPTS        4
+#define IPV6_2292RTHDR          5
+#define IPV6_2292PKTOPTIONS     6
+#define IPV6_CHECKSUM           7
+#define IPV6_2292HOPLIMIT       8
+#define IPV6_NEXTHOP            9
+#define IPV6_AUTHHDR            10
+#define IPV6_UNICAST_HOPS       16
+#define IPV6_MULTICAST_IF       17
+#define IPV6_MULTICAST_HOPS     18
+#define IPV6_MULTICAST_LOOP     19
+#define IPV6_JOIN_GROUP         20
+#define IPV6_LEAVE_GROUP        21
+#define IPV6_ROUTER_ALERT       22
+#define IPV6_MTU_DISCOVER       23
+#define IPV6_MTU                24
+#define IPV6_RECVERR            25
+#define IPV6_V6ONLY             26
+#define IPV6_JOIN_ANYCAST       27
+#define IPV6_LEAVE_ANYCAST      28
+#define IPV6_MULTICAST_ALL      29
+#define IPV6_ROUTER_ALERT_ISOLATE 30
+#define IPV6_IPSEC_POLICY       34
+#define IPV6_XFRM_POLICY        35
+#define IPV6_HDRINCL            36
+
+#define IPV6_RECVPKTINFO        49
+#define IPV6_PKTINFO            50
+#define IPV6_RECVHOPLIMIT       51
+#define IPV6_HOPLIMIT           52
+#define IPV6_RECVHOPOPTS        53
+#define IPV6_HOPOPTS            54
+#define IPV6_RTHDRDSTOPTS       55
+#define IPV6_RECVRTHDR          56
+#define IPV6_RTHDR              57
+#define IPV6_RECVDSTOPTS        58
+#define IPV6_DSTOPTS            59
+#define IPV6_RECVPATHMTU        60
+#define IPV6_PATHMTU            61
+#define IPV6_DONTFRAG           62
+#define IPV6_RECVTCLASS         66
+#define IPV6_TCLASS             67
+#define IPV6_AUTOFLOWLABEL      70
+#define IPV6_ADDR_PREFERENCES   72
+#define IPV6_MINHOPCOUNT        73
+#define IPV6_ORIGDSTADDR        74
+#define IPV6_RECVORIGDSTADDR    IPV6_ORIGDSTADDR
+#define IPV6_TRANSPARENT        75
+#define IPV6_UNICAST_IF         76
+#define IPV6_RECVFRAGSIZE       77
+#define IPV6_FREEBIND           78
+
+#define IPV6_ADD_MEMBERSHIP     IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP    IPV6_LEAVE_GROUP
+#define IPV6_RXHOPOPTS          IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS          IPV6_DSTOPTS
+
+#define IPV6_PMTUDISC_DONT      0
+#define IPV6_PMTUDISC_WANT      1
+#define IPV6_PMTUDISC_DO        2
+#define IPV6_PMTUDISC_PROBE     3
+#define IPV6_PMTUDISC_INTERFACE 4
+#define IPV6_PMTUDISC_OMIT      5
+
+#define IPV6_PREFER_SRC_TMP            0x0001
+#define IPV6_PREFER_SRC_PUBLIC         0x0002
+#define IPV6_PREFER_SRC_PUBTMP_DEFAULT 0x0100
+#define IPV6_PREFER_SRC_COA            0x0004
+#define IPV6_PREFER_SRC_HOME           0x0400
+#define IPV6_PREFER_SRC_CGA            0x0008
+#define IPV6_PREFER_SRC_NONCGA         0x0800
+
+#define IPV6_RTHDR_LOOSE        0
+#define IPV6_RTHDR_STRICT       1
+
+#define IPV6_RTHDR_TYPE_0       0
+
+#define __UAPI_DEF_IN_ADDR      0
+#define __UAPI_DEF_IN_IPPROTO   0
+#define __UAPI_DEF_IN_PKTINFO   0
+#define __UAPI_DEF_IP_MREQ      0
+#define __UAPI_DEF_SOCKADDR_IN  0
+#define __UAPI_DEF_IN_CLASS     0
+#define __UAPI_DEF_IN6_ADDR     0
+#define __UAPI_DEF_IN6_ADDR_ALT 0
+#define __UAPI_DEF_SOCKADDR_IN6 0
+#define __UAPI_DEF_IPV6_MREQ    0
+#define __UAPI_DEF_IPPROTO_V6   0
+#define __UAPI_DEF_IPV6_OPTIONS 0
+#define __UAPI_DEF_IN6_PKTINFO  0
+#define __UAPI_DEF_IP6_MTUINFO  0
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/kal/libc/newlib/porting/include/netinet/ip.h b/kal/libc/newlib/porting/include/netinet/ip.h
new file mode 100644
index 0000000..0ae132a
--- /dev/null
+++ b/kal/libc/newlib/porting/include/netinet/ip.h
@@ -0,0 +1,199 @@
+#ifndef _NETINET_IP_H
+#define _NETINET_IP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#include <netinet/in.h>
+
+struct timestamp {
+	uint8_t len;
+	uint8_t ptr;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int flags:4;
+	unsigned int overflow:4;
+#else
+	unsigned int overflow:4;
+	unsigned int flags:4;
+#endif
+	uint32_t data[9];
+  };
+
+struct iphdr {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int ihl:4;
+	unsigned int version:4;
+#else
+	unsigned int version:4;
+	unsigned int ihl:4;
+#endif
+	uint8_t tos;
+	uint16_t tot_len;
+	uint16_t id;
+	uint16_t frag_off;
+	uint8_t ttl;
+	uint8_t protocol;
+	uint16_t check;
+	uint32_t saddr;
+	uint32_t daddr;
+};
+
+struct ip {
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int ip_hl:4;
+	unsigned int ip_v:4;
+#else
+	unsigned int ip_v:4;
+	unsigned int ip_hl:4;
+#endif
+	uint8_t ip_tos;
+	uint16_t ip_len;
+	uint16_t ip_id;
+	uint16_t ip_off;
+	uint8_t ip_ttl;
+	uint8_t ip_p;
+	uint16_t ip_sum;
+	struct in_addr ip_src, ip_dst;
+};
+
+#define	IP_RF 0x8000
+#define	IP_DF 0x4000
+#define	IP_MF 0x2000
+#define	IP_OFFMASK 0x1fff
+
+struct ip_timestamp {
+	uint8_t ipt_code;
+	uint8_t ipt_len;
+	uint8_t ipt_ptr;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int ipt_flg:4;
+	unsigned int ipt_oflw:4;
+#else
+	unsigned int ipt_oflw:4;
+	unsigned int ipt_flg:4;
+#endif
+	uint32_t data[9];
+};
+
+#define	IPVERSION	4
+#define	IP_MAXPACKET	65535
+
+#define	IPTOS_ECN_MASK		0x03
+#define	IPTOS_ECN(x)		((x) & IPTOS_ECN_MASK)
+#define	IPTOS_ECN_NOT_ECT	0x00
+#define	IPTOS_ECN_ECT1		0x01
+#define	IPTOS_ECN_ECT0		0x02
+#define	IPTOS_ECN_CE		0x03
+
+#define	IPTOS_DSCP_MASK		0xfc
+#define	IPTOS_DSCP(x)		((x) & IPTOS_DSCP_MASK)
+#define	IPTOS_DSCP_AF11		0x28
+#define	IPTOS_DSCP_AF12		0x30
+#define	IPTOS_DSCP_AF13		0x38
+#define	IPTOS_DSCP_AF21		0x48
+#define	IPTOS_DSCP_AF22		0x50
+#define	IPTOS_DSCP_AF23		0x58
+#define	IPTOS_DSCP_AF31		0x68
+#define	IPTOS_DSCP_AF32		0x70
+#define	IPTOS_DSCP_AF33		0x78
+#define	IPTOS_DSCP_AF41		0x88
+#define	IPTOS_DSCP_AF42		0x90
+#define	IPTOS_DSCP_AF43		0x98
+#define	IPTOS_DSCP_EF		0xb8
+
+#define	IPTOS_CLASS_MASK	0xe0
+#define	IPTOS_CLASS(x)		((x) & IPTOS_CLASS_MASK)
+#define	IPTOS_CLASS_CS0		0x00
+#define	IPTOS_CLASS_CS1		0x20
+#define	IPTOS_CLASS_CS2		0x40
+#define	IPTOS_CLASS_CS3		0x60
+#define	IPTOS_CLASS_CS4		0x80
+#define	IPTOS_CLASS_CS5		0xa0
+#define	IPTOS_CLASS_CS6		0xc0
+#define	IPTOS_CLASS_CS7		0xe0
+#define	IPTOS_CLASS_DEFAULT	IPTOS_CLASS_CS0
+
+#define	IPTOS_TOS_MASK		0x1E
+#define	IPTOS_TOS(tos)		((tos) & IPTOS_TOS_MASK)
+#define	IPTOS_LOWDELAY		0x10
+#define	IPTOS_THROUGHPUT	0x08
+#define	IPTOS_RELIABILITY	0x04
+#define	IPTOS_LOWCOST		0x02
+#define	IPTOS_MINCOST		IPTOS_LOWCOST
+
+#define	IPTOS_PREC_MASK			0xe0
+#define	IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
+#define	IPTOS_PREC_NETCONTROL		0xe0
+#define	IPTOS_PREC_INTERNETCONTROL	0xc0
+#define	IPTOS_PREC_CRITIC_ECP		0xa0
+#define	IPTOS_PREC_FLASHOVERRIDE	0x80
+#define	IPTOS_PREC_FLASH		0x60
+#define	IPTOS_PREC_IMMEDIATE		0x40
+#define	IPTOS_PREC_PRIORITY		0x20
+#define	IPTOS_PREC_ROUTINE		0x00
+
+#define	IPOPT_COPY		0x80
+#define	IPOPT_CLASS_MASK	0x60
+#define	IPOPT_NUMBER_MASK	0x1f
+
+#define	IPOPT_COPIED(o)		((o) & IPOPT_COPY)
+#define	IPOPT_CLASS(o)		((o) & IPOPT_CLASS_MASK)
+#define	IPOPT_NUMBER(o)		((o) & IPOPT_NUMBER_MASK)
+
+#define	IPOPT_CONTROL		0x00
+#define	IPOPT_RESERVED1		0x20
+#define	IPOPT_DEBMEAS		0x40
+#define	IPOPT_MEASUREMENT       IPOPT_DEBMEAS
+#define	IPOPT_RESERVED2		0x60
+
+#define	IPOPT_EOL		0
+#define	IPOPT_END		IPOPT_EOL
+#define	IPOPT_NOP		1
+#define	IPOPT_NOOP		IPOPT_NOP
+
+#define	IPOPT_RR		7
+#define	IPOPT_TS		68
+#define	IPOPT_TIMESTAMP		IPOPT_TS
+#define	IPOPT_SECURITY		130
+#define	IPOPT_SEC		IPOPT_SECURITY
+#define	IPOPT_LSRR		131
+#define	IPOPT_SATID		136
+#define	IPOPT_SID		IPOPT_SATID
+#define	IPOPT_SSRR		137
+#define	IPOPT_RA		148
+
+#define	IPOPT_OPTVAL		0
+#define	IPOPT_OLEN		1
+#define	IPOPT_OFFSET		2
+#define	IPOPT_MINOFF		4
+
+#define	MAX_IPOPTLEN		40
+
+#define	IPOPT_TS_TSONLY		0
+#define	IPOPT_TS_TSANDADDR	1
+#define	IPOPT_TS_PRESPEC	3
+
+#define	IPOPT_SECUR_UNCLASS	0x0000
+#define	IPOPT_SECUR_CONFID	0xf135
+#define	IPOPT_SECUR_EFTO	0x789a
+#define	IPOPT_SECUR_MMMM	0xbc4d
+#define	IPOPT_SECUR_RESTR	0xaf13
+#define	IPOPT_SECUR_SECRET	0xd788
+#define	IPOPT_SECUR_TOPSECRET	0x6bc5
+
+#define	MAXTTL		255
+#define	IPDEFTTL	64
+#define	IPFRAGTTL	60
+#define	IPTTLDEC	1
+
+#define	IP_MSS		576
+
+#define __UAPI_DEF_IPHDR	0
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/kal/libc/newlib/porting/include/semaphore.h b/kal/libc/newlib/porting/include/semaphore.h
new file mode 100644
index 0000000..16fa96c
--- /dev/null
+++ b/kal/libc/newlib/porting/include/semaphore.h
@@ -0,0 +1,28 @@
+#ifndef _ADAPT_SEMAPHORE_H
+#define _ADAPT_SEMAPHORE_H
+
+#include <sys/features.h>
+#include <time.h>
+#include <fcntl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SEM_FAILED ((sem_t *)0)
+
+typedef struct {
+    volatile int __val[4*sizeof(long)/sizeof(int)];
+} sem_t;
+
+int    sem_init(sem_t *, int, unsigned);
+int    sem_destroy(sem_t *);
+int    sem_wait(sem_t *);
+int    sem_post(sem_t *);
+int    sem_timedwait(sem_t *__restrict, const struct timespec *__restrict);
+int    sem_getvalue(sem_t *__restrict, int *__restrict);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _ADAPT_SEMAPHORE_H */
diff --git a/kal/libc/newlib/porting/include/sys/_pthreadtypes.h b/kal/libc/newlib/porting/include/sys/_pthreadtypes.h
new file mode 100644
index 0000000..e12c049
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/_pthreadtypes.h
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _ADAPT_SYS_PTHREADTYPES_H
+#define	_ADAPT_SYS_PTHREADTYPES_H
+
+#define pthread_t __pthread_t_discard
+#define pthread_attr_t __pthread_attr_t_discard
+#define pthread_mutex_t __pthread_mutex_t_discard
+#define pthread_mutexattr_t __pthread_mutexattr_t_discard
+#define pthread_cond_t __pthread_cond_t_discard
+#define pthread_condattr_t __pthread_condattr_t_discard
+#define pthread_once_t __pthread_once_t_discard
+#define pthread_barrierattr_t __pthread_barrierattr_t_discard
+#define pthread_spinlock_t __pthread_spinlock_t_discard
+
+#include_next <sys/_pthreadtypes.h>
+
+#undef pthread_t
+#undef pthread_attr_t
+#undef pthread_mutex_t
+#undef pthread_mutexattr_t
+#undef pthread_cond_t
+#undef pthread_condattr_t
+#undef pthread_once_t
+#undef pthread_barrierattr_t
+#undef pthread_spinlock_t
+#undef _PTHREAD_MUTEX_INITIALIZER
+#undef _PTHREAD_COND_INITIALIZER
+#undef _PTHREAD_ONCE_INIT
+
+#undef PTHREAD_STACK_MIN
+
+#include "los_config.h"
+#define PTHREAD_STACK_MIN LOSCFG_BASE_CORE_TSK_MIN_STACK_SIZE
+
+typedef unsigned long pthread_t;            /* identify a thread */
+
+typedef struct {
+    unsigned int detachstate;
+    unsigned int schedpolicy;
+    struct sched_param schedparam;
+    unsigned int inheritsched;
+    unsigned int scope;
+    unsigned int stackaddr_set;
+    void *stackaddr;
+    unsigned int stacksize_set;
+    size_t stacksize;
+} pthread_attr_t;
+
+#include "los_list.h"
+typedef struct { unsigned int magic; unsigned int handle; } pthread_mutex_t;
+
+typedef struct { unsigned type; } pthread_mutexattr_t;
+
+#define _MUX_MAGIC 0xEBCFDEA0
+#define _MUX_INVALID_HANDLE 0xEEEEEEEF
+
+#define _PTHREAD_MUTEX_INITIALIZER  { _MUX_MAGIC, _MUX_INVALID_HANDLE }
+
+#include "los_event.h"
+
+typedef struct pthread_cond {
+  volatile int count;      /**< The number of tasks blocked by condition */
+  EVENT_CB_S event;        /**< Event object*/
+  pthread_mutex_t* mutex;  /**< Mutex locker for condition variable protection */
+  volatile int value;      /**< Condition variable state value*/
+  int clock;
+} pthread_cond_t;
+
+#define _PTHREAD_COND_INITIALIZER   { 0 }
+
+typedef struct { int clock; } pthread_condattr_t;
+
+typedef __uint32_t pthread_key_t;        /* thread-specific data keys */
+
+typedef int pthread_once_t;
+
+#define _PTHREAD_ONCE_INIT  { 0 }
+
+typedef struct { unsigned __attr; } pthread_barrierattr_t;
+
+typedef int pthread_spinlock_t;
+
+#endif /* ! _ADAPT_SYS_PTHREADTYPES_H */
diff --git a/kal/libc/newlib/porting/include/sys/fcntl.h b/kal/libc/newlib/porting/include/sys/fcntl.h
new file mode 100644
index 0000000..aa3a145
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/fcntl.h
@@ -0,0 +1,12 @@
+//
+// Created by simonli on 11/23/21.
+//
+
+#ifndef _ADAPT_SYS_FCNTL_H
+#define _ADAPT_SYS_FCNTL_H
+
+#include_next <sys/fcntl.h>
+
+#define O_NDELAY    _FNDELAY
+
+#endif //_ADAPT_SYS_FCNTL_H
diff --git a/kal/libc/newlib/porting/include/sys/features.h b/kal/libc/newlib/porting/include/sys/features.h
new file mode 100644
index 0000000..0498222
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/features.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _ADAPT_SYS_FEATURES_H
+#define _ADAPT_SYS_FEATURES_H
+
+#define _GNU_SOURCE 1
+#define __USE_NEWLIB__
+
+/* adapt time.h */
+#define _POSIX_TIMERS 1
+#define _POSIX_CPUTIME 1
+#define _POSIX_THREAD_CPUTIME 1
+#define _POSIX_MONOTONIC_CLOCK 1
+
+/* adapt sys/signal.h */
+#define _POSIX_REALTIME_SIGNALS 1
+
+/* adapt pthread */
+#define _POSIX_THREADS 1
+#define _POSIX_TIMEOUTS
+#define _POSIX_THREAD_PRIORITY_SCHEDULING
+#define _UNIX98_THREAD_MUTEX_ATTRIBUTES
+
+#include_next <sys/features.h>
+
+#endif /* _ADAPT_SYS_FEATURES_H */
diff --git a/kal/libc/newlib/porting/include/sys/ioctl.h b/kal/libc/newlib/porting/include/sys/ioctl.h
new file mode 100644
index 0000000..73f9e9e
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/ioctl.h
@@ -0,0 +1,238 @@
+#ifndef	_ADAPT_SYS_IOCTL_H
+#define	_ADAPT_SYS_IOCTL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#if 0
+#define _IOC(a,b,c,d) ( ((a)<<30) | ((b)<<8) | (c) | ((d)<<16) )
+#define _IOC_NONE  0U
+#define _IOC_WRITE 1U
+#define _IOC_READ  2U
+
+#define _IO(a,b) _IOC(_IOC_NONE,(a),(b),0)
+#define _IOW(a,b,c) _IOC(_IOC_WRITE,(a),(b),sizeof(c))
+#define _IOR(a,b,c) _IOC(_IOC_READ,(a),(b),sizeof(c))
+#define _IOWR(a,b,c) _IOC(_IOC_READ|_IOC_WRITE,(a),(b),sizeof(c))
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425
+#define TIOCSBRK	0x5427
+#define TIOCCBRK	0x5428
+#define TIOCGSID	0x5429
+#define TIOCGRS485	0x542E
+#define TIOCSRS485	0x542F
+#define TIOCGPTN	0x80045430
+#define TIOCSPTLCK	0x40045431
+#define TIOCGDEV	0x80045432
+#define TCGETX		0x5432
+#define TCSETX		0x5433
+#define TCSETXF		0x5434
+#define TCSETXW		0x5435
+#define TIOCSIG		0x40045436
+#define TIOCVHANGUP	0x5437
+#define TIOCGPKT	0x80045438
+#define TIOCGPTLCK	0x80045439
+#define TIOCGEXCL	0x80045440
+#define TIOCGPTPEER	0x5441
+#define TIOCGISO7816	0x80285442
+#define TIOCSISO7816	0xc0285443
+
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458
+#define TIOCSERGETLSR   0x5459
+#define TIOCSERGETMULTI 0x545A
+#define TIOCSERSETMULTI 0x545B
+
+#define TIOCMIWAIT	0x545C
+#define TIOCGICOUNT	0x545D
+#define FIOQSIZE	0x545e
+
+#define TIOCM_LE        0x001
+#define TIOCM_DTR       0x002
+#define TIOCM_RTS       0x004
+#define TIOCM_ST        0x008
+#define TIOCM_SR        0x010
+#define TIOCM_CTS       0x020
+#define TIOCM_CAR       0x040
+#define TIOCM_RNG       0x080
+#define TIOCM_DSR       0x100
+#define TIOCM_CD        TIOCM_CAR
+#define TIOCM_RI        TIOCM_RNG
+#define TIOCM_OUT1      0x2000
+#define TIOCM_OUT2      0x4000
+#define TIOCM_LOOP      0x8000
+
+#define FIOSETOWN       0x8901
+#define SIOCSPGRP       0x8902
+#define FIOGETOWN       0x8903
+#define SIOCGPGRP       0x8904
+#define SIOCATMARK      0x8905
+#if __LONG_MAX__ == 0x7fffffff
+#define SIOCGSTAMP      _IOR(0x89, 6, char[16])
+#define SIOCGSTAMPNS    _IOR(0x89, 7, char[16])
+#else
+#define SIOCGSTAMP      0x8906
+#define SIOCGSTAMPNS    0x8907
+#endif
+
+#define N_TTY           0
+#define N_SLIP          1
+#define N_MOUSE         2
+#define N_PPP           3
+#define N_STRIP         4
+#define N_AX25          5
+#define N_X25           6
+#define N_6PACK         7
+#define N_MASC          8
+#define N_R3964         9
+#define N_PROFIBUS_FDL  10
+#define N_IRDA          11
+#define N_SMSBLOCK      12
+#define N_HDLC          13
+#define N_SYNC_PPP      14
+#define N_HCI           15
+#define N_GIGASET_M101  16
+#define N_SLCAN         17
+#define N_PPS           18
+#define N_V253          19
+#define N_CAIF          20
+#define N_GSM0710       21
+#define N_TI_WL         22
+#define N_TRACESINK     23
+#define N_TRACEROUTER   24
+#define N_NCI           25
+#define N_SPEAKUP       26
+#define N_NULL          27
+
+#define TIOCPKT_DATA       0
+#define TIOCPKT_FLUSHREAD  1
+#define TIOCPKT_FLUSHWRITE 2
+#define TIOCPKT_STOP       4
+#define TIOCPKT_START      8
+#define TIOCPKT_NOSTOP    16
+#define TIOCPKT_DOSTOP    32
+#define TIOCPKT_IOCTL     64
+
+#define TIOCSER_TEMT 1
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define SIOCADDRT          0x890B
+#define SIOCDELRT          0x890C
+#define SIOCRTMSG          0x890D
+
+#define SIOCGIFNAME        0x8910
+#define SIOCSIFLINK        0x8911
+#define SIOCGIFCONF        0x8912
+#define SIOCGIFFLAGS       0x8913
+#define SIOCSIFFLAGS       0x8914
+#define SIOCGIFADDR        0x8915
+#define SIOCSIFADDR        0x8916
+#define SIOCGIFDSTADDR     0x8917
+#define SIOCSIFDSTADDR     0x8918
+#define SIOCGIFBRDADDR     0x8919
+#define SIOCSIFBRDADDR     0x891a
+#define SIOCGIFNETMASK     0x891b
+#define SIOCSIFNETMASK     0x891c
+#define SIOCGIFMETRIC      0x891d
+#define SIOCSIFMETRIC      0x891e
+#define SIOCGIFMEM         0x891f
+#define SIOCSIFMEM         0x8920
+#define SIOCGIFMTU         0x8921
+#define SIOCSIFMTU         0x8922
+#define SIOCSIFNAME        0x8923
+#define SIOCSIFHWADDR      0x8924
+#define SIOCGIFENCAP       0x8925
+#define SIOCSIFENCAP       0x8926
+#define SIOCGIFHWADDR      0x8927
+#define SIOCGIFSLAVE       0x8929
+#define SIOCSIFSLAVE       0x8930
+#define SIOCADDMULTI       0x8931
+#define SIOCDELMULTI       0x8932
+#define SIOCGIFINDEX       0x8933
+#define SIOGIFINDEX        SIOCGIFINDEX
+#define SIOCSIFPFLAGS      0x8934
+#define SIOCGIFPFLAGS      0x8935
+#define SIOCDIFADDR        0x8936
+#define SIOCSIFHWBROADCAST 0x8937
+#define SIOCGIFCOUNT       0x8938
+
+#define SIOCGIFBR          0x8940
+#define SIOCSIFBR          0x8941
+
+#define SIOCGIFTXQLEN      0x8942
+#define SIOCSIFTXQLEN      0x8943
+
+#define SIOCDARP           0x8953
+#define SIOCGARP           0x8954
+#define SIOCSARP           0x8955
+
+#define SIOCDRARP          0x8960
+#define SIOCGRARP          0x8961
+#define SIOCSRARP          0x8962
+
+#define SIOCGIFMAP         0x8970
+#define SIOCSIFMAP         0x8971
+
+#define SIOCADDDLCI        0x8980
+#define SIOCDELDLCI        0x8981
+
+#define SIOCDEVPRIVATE     0x89F0
+#define SIOCPROTOPRIVATE   0x89E0
+
+int ioctl (int, int, ...);
+#endif
+#ifdef __cplusplus
+}
+#endif
+#endif /* _ADAPT_SYS_IOCTL_H */
diff --git a/kal/libc/newlib/porting/include/sys/mount.h b/kal/libc/newlib/porting/include/sys/mount.h
new file mode 100644
index 0000000..60cf47e
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/mount.h
@@ -0,0 +1,55 @@
+#ifndef _ADAPT_SYS_MOUNT_H
+#define _ADAPT_SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define MS_RDONLY      1
+#define MS_NOSUID      2
+#define MS_NODEV       4
+#define MS_NOEXEC      8
+#define MS_SYNCHRONOUS 16
+#define MS_REMOUNT     32
+#define MS_MANDLOCK    64
+#define MS_DIRSYNC     128
+#define MS_NOATIME     1024
+#define MS_NODIRATIME  2048
+#define MS_BIND        4096
+#define MS_MOVE        8192
+#define MS_REC         16384
+#define MS_SILENT      32768
+#define MS_POSIXACL    (1<<16)
+#define MS_UNBINDABLE  (1<<17)
+#define MS_PRIVATE     (1<<18)
+#define MS_SLAVE       (1<<19)
+#define MS_SHARED      (1<<20)
+#define MS_RELATIME    (1<<21)
+#define MS_KERNMOUNT   (1<<22)
+#define MS_I_VERSION   (1<<23)
+#define MS_STRICTATIME (1<<24)
+#define MS_LAZYTIME    (1<<25)
+#define MS_NOREMOTELOCK (1<<27)
+#define MS_NOSEC       (1<<28)
+#define MS_BORN        (1<<29)
+#define MS_ACTIVE      (1<<30)
+#define MS_NOUSER      (1U<<31)
+
+#define MS_RMT_MASK (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|MS_LAZYTIME)
+
+#define MS_MGC_VAL 0xc0ed0000
+#define MS_MGC_MSK 0xffff0000
+
+#define MNT_FORCE       1
+#define MNT_DETACH      2
+#define MNT_EXPIRE      4
+#define UMOUNT_NOFOLLOW 8
+
+int mount(const char *, const char *, const char *, unsigned long, const void *);
+int umount(const char *);
+int umount2(const char *, int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ADAPT_SYS_MOUNT_H */
diff --git a/kal/libc/newlib/porting/include/sys/prctl.h b/kal/libc/newlib/porting/include/sys/prctl.h
new file mode 100644
index 0000000..7ecfb72
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/prctl.h
@@ -0,0 +1,167 @@
+#ifndef _ADAPT_SYS_PRCTL_H
+#define _ADAPT_SYS_PRCTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+#if 0
+#define PR_SET_PDEATHSIG  1
+#define PR_GET_PDEATHSIG  2
+#define PR_GET_DUMPABLE   3
+#define PR_SET_DUMPABLE   4
+#define PR_GET_UNALIGN   5
+#define PR_SET_UNALIGN   6
+#define PR_UNALIGN_NOPRINT 1
+#define PR_UNALIGN_SIGBUS 2
+#define PR_GET_KEEPCAPS   7
+#define PR_SET_KEEPCAPS   8
+#define PR_GET_FPEMU  9
+#define PR_SET_FPEMU 10
+#define PR_FPEMU_NOPRINT 1
+#define PR_FPEMU_SIGFPE 2
+#define PR_GET_FPEXC 11
+#define PR_SET_FPEXC 12
+#define PR_FP_EXC_SW_ENABLE 0x80
+#define PR_FP_EXC_DIV  0x010000
+#define PR_FP_EXC_OVF  0x020000
+#define PR_FP_EXC_UND  0x040000
+#define PR_FP_EXC_RES  0x080000
+#define PR_FP_EXC_INV  0x100000
+#define PR_FP_EXC_DISABLED 0
+#define PR_FP_EXC_NONRECOV 1
+#define PR_FP_EXC_ASYNC 2
+#define PR_FP_EXC_PRECISE 3
+#define PR_GET_TIMING   13
+#define PR_SET_TIMING   14
+#define PR_TIMING_STATISTICAL  0
+#define PR_TIMING_TIMESTAMP    1
+#define PR_SET_NAME    15
+#define PR_GET_NAME    16
+#define PR_GET_ENDIAN 19
+#define PR_SET_ENDIAN 20
+#define PR_ENDIAN_BIG 0
+#define PR_ENDIAN_LITTLE 1
+#define PR_ENDIAN_PPC_LITTLE 2
+#define PR_GET_SECCOMP 21
+#define PR_SET_SECCOMP 22
+#define PR_CAPBSET_READ 23
+#define PR_CAPBSET_DROP 24
+#define PR_GET_TSC 25
+#define PR_SET_TSC 26
+#define PR_TSC_ENABLE 1
+#define PR_TSC_SIGSEGV 2
+#define PR_GET_SECUREBITS 27
+#define PR_SET_SECUREBITS 28
+#define PR_SET_TIMERSLACK 29
+#define PR_GET_TIMERSLACK 30
+
+#define PR_TASK_PERF_EVENTS_DISABLE             31
+#define PR_TASK_PERF_EVENTS_ENABLE              32
+
+#define PR_MCE_KILL     33
+#define PR_MCE_KILL_CLEAR   0
+#define PR_MCE_KILL_SET     1
+#define PR_MCE_KILL_LATE    0
+#define PR_MCE_KILL_EARLY   1
+#define PR_MCE_KILL_DEFAULT 2
+#define PR_MCE_KILL_GET 34
+
+#define PR_SET_MM               35
+#define PR_SET_MM_START_CODE           1
+#define PR_SET_MM_END_CODE             2
+#define PR_SET_MM_START_DATA           3
+#define PR_SET_MM_END_DATA             4
+#define PR_SET_MM_START_STACK          5
+#define PR_SET_MM_START_BRK            6
+#define PR_SET_MM_BRK                  7
+#define PR_SET_MM_ARG_START            8
+#define PR_SET_MM_ARG_END              9
+#define PR_SET_MM_ENV_START            10
+#define PR_SET_MM_ENV_END              11
+#define PR_SET_MM_AUXV                 12
+#define PR_SET_MM_EXE_FILE             13
+#define PR_SET_MM_MAP                  14
+#define PR_SET_MM_MAP_SIZE             15
+
+struct prctl_mm_map {
+	uint64_t start_code;
+	uint64_t end_code;
+	uint64_t start_data;
+	uint64_t end_data;
+	uint64_t start_brk;
+	uint64_t brk;
+	uint64_t start_stack;
+	uint64_t arg_start;
+	uint64_t arg_end;
+	uint64_t env_start;
+	uint64_t env_end;
+	uint64_t *auxv;
+	uint32_t auxv_size;
+	uint32_t exe_fd;
+};
+
+#define PR_SET_PTRACER 0x59616d61
+#define PR_SET_PTRACER_ANY (-1UL)
+
+#define PR_SET_CHILD_SUBREAPER  36
+#define PR_GET_CHILD_SUBREAPER  37
+
+#define PR_SET_NO_NEW_PRIVS     38
+#define PR_GET_NO_NEW_PRIVS     39
+
+#define PR_GET_TID_ADDRESS      40
+
+#define PR_SET_THP_DISABLE      41
+#define PR_GET_THP_DISABLE      42
+
+#define PR_MPX_ENABLE_MANAGEMENT  43
+#define PR_MPX_DISABLE_MANAGEMENT 44
+
+#define PR_SET_FP_MODE          45
+#define PR_GET_FP_MODE          46
+#define PR_FP_MODE_FR (1 << 0)
+#define PR_FP_MODE_FRE (1 << 1)
+
+#define PR_CAP_AMBIENT          47
+#define PR_CAP_AMBIENT_IS_SET   1
+#define PR_CAP_AMBIENT_RAISE    2
+#define PR_CAP_AMBIENT_LOWER    3
+#define PR_CAP_AMBIENT_CLEAR_ALL 4
+
+#define PR_SVE_SET_VL           50
+#define PR_SVE_SET_VL_ONEXEC (1 << 18)
+#define PR_SVE_GET_VL           51
+#define PR_SVE_VL_LEN_MASK 0xffff
+#define PR_SVE_VL_INHERIT (1 << 17)
+
+#define PR_GET_SPECULATION_CTRL 52
+#define PR_SET_SPECULATION_CTRL 53
+#define PR_SPEC_STORE_BYPASS 0
+#define PR_SPEC_INDIRECT_BRANCH 1
+#define PR_SPEC_NOT_AFFECTED 0
+#define PR_SPEC_PRCTL (1UL << 0)
+#define PR_SPEC_ENABLE (1UL << 1)
+#define PR_SPEC_DISABLE (1UL << 2)
+#define PR_SPEC_FORCE_DISABLE (1UL << 3)
+#define PR_SPEC_DISABLE_NOEXEC (1UL << 4)
+
+#define PR_PAC_RESET_KEYS       54
+#define PR_PAC_APIAKEY (1UL << 0)
+#define PR_PAC_APIBKEY (1UL << 1)
+#define PR_PAC_APDAKEY (1UL << 2)
+#define PR_PAC_APDBKEY (1UL << 3)
+#define PR_PAC_APGAKEY (1UL << 4)
+
+#define PR_SET_TAGGED_ADDR_CTRL 55
+#define PR_GET_TAGGED_ADDR_CTRL 56
+#define PR_TAGGED_ADDR_ENABLE (1UL << 0)
+
+int prctl (int, ...);
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ADAPT_SYS_PRCTL_H */
diff --git a/kal/libc/newlib/porting/include/sys/sched.h b/kal/libc/newlib/porting/include/sys/sched.h
new file mode 100644
index 0000000..ceea536
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/sched.h
@@ -0,0 +1,24 @@
+#ifndef _ADAPT_SYS_SCHED_H
+#define _ADAPT_SYS_SCHED_H
+
+#include <sys/types.h>
+
+#define sched_param     sched_param_discard
+
+#include_next <sys/sched.h>
+
+#undef sched_param
+
+struct sched_param {
+    int sched_priority;
+    int __reserved1;
+    struct {
+        time_t __reserved1;
+        long __reserved2;
+    } __reserved2[2];
+    int __reserved3;
+};
+
+typedef struct cpu_set_t { unsigned long __bits[128/sizeof(long)]; } cpu_set_t;
+
+#endif /* _ADAPT_SYS_SCHED_H */
diff --git a/kal/libc/newlib/porting/include/sys/socket.h b/kal/libc/newlib/porting/include/sys/socket.h
new file mode 100644
index 0000000..1382b54
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/socket.h
@@ -0,0 +1,413 @@
+#ifndef	_SYS_SOCKET_H
+#define	_SYS_SOCKET_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "sys/features.h"
+
+#define __NEED_socklen_t
+#define __NEED_sa_family_t
+#define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_uid_t
+#define __NEED_pid_t
+#define __NEED_gid_t
+#define __NEED_struct_iovec
+
+#include <sys/types.h>
+typedef unsigned socklen_t;
+typedef unsigned short sa_family_t;
+
+struct msghdr {
+	void *msg_name;
+	socklen_t msg_namelen;
+	struct iovec *msg_iov;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1;
+#endif
+	int msg_iovlen;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad1;
+#endif
+	void *msg_control;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad2;
+#endif
+	socklen_t msg_controllen;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad2;
+#endif
+	int msg_flags;
+};
+
+struct cmsghdr {
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __BIG_ENDIAN
+	int __pad1;
+#endif
+	socklen_t cmsg_len;
+#if __LONG_MAX > 0x7fffffff && __BYTE_ORDER == __LITTLE_ENDIAN
+	int __pad1;
+#endif
+	int cmsg_level;
+	int cmsg_type;
+};
+
+#ifdef _GNU_SOURCE
+struct ucred {
+	pid_t pid;
+	uid_t uid;
+	gid_t gid;
+};
+
+struct mmsghdr {
+	struct msghdr msg_hdr;
+	unsigned int  msg_len;
+};
+
+struct timespec;
+
+int sendmmsg (int, struct mmsghdr *, unsigned int, unsigned int);
+int recvmmsg (int, struct mmsghdr *, unsigned int, unsigned int, struct timespec *);
+#endif
+
+struct linger {
+	int l_onoff;
+	int l_linger;
+};
+
+#define SHUT_RD 0
+#define SHUT_WR 1
+#define SHUT_RDWR 2
+
+#ifndef SOCK_STREAM
+#define SOCK_STREAM    1
+#define SOCK_DGRAM     2
+#endif
+
+#define SOCK_RAW       3
+#define SOCK_RDM       4
+#define SOCK_SEQPACKET 5
+#define SOCK_DCCP      6
+#define SOCK_PACKET    10
+
+#ifndef SOCK_CLOEXEC
+#define SOCK_CLOEXEC   02000000
+#define SOCK_NONBLOCK  04000
+#endif
+
+#define PF_UNSPEC       0
+#define PF_LOCAL        1
+#define PF_UNIX         PF_LOCAL
+#define PF_FILE         PF_LOCAL
+#define PF_INET         2
+#define PF_AX25         3
+#define PF_IPX          4
+#define PF_APPLETALK    5
+#define PF_NETROM       6
+#define PF_BRIDGE       7
+#define PF_ATMPVC       8
+#define PF_X25          9
+#define PF_INET6        10
+#define PF_ROSE         11
+#define PF_DECnet       12
+#define PF_NETBEUI      13
+#define PF_SECURITY     14
+#define PF_KEY          15
+#define PF_NETLINK      16
+#define PF_ROUTE        PF_NETLINK
+#define PF_PACKET       17
+#define PF_ASH          18
+#define PF_ECONET       19
+#define PF_ATMSVC       20
+#define PF_RDS          21
+#define PF_SNA          22
+#define PF_IRDA         23
+#define PF_PPPOX        24
+#define PF_WANPIPE      25
+#define PF_LLC          26
+#define PF_IB           27
+#define PF_MPLS         28
+#define PF_CAN          29
+#define PF_TIPC         30
+#define PF_BLUETOOTH    31
+#define PF_IUCV         32
+#define PF_RXRPC        33
+#define PF_ISDN         34
+#define PF_PHONET       35
+#define PF_IEEE802154   36
+#define PF_CAIF         37
+#define PF_ALG          38
+#define PF_NFC          39
+#define PF_VSOCK        40
+#define PF_KCM          41
+#define PF_QIPCRTR      42
+#define PF_SMC          43
+#define PF_XDP          44
+#define PF_MAX          45
+
+#define AF_UNSPEC       PF_UNSPEC
+#define AF_LOCAL        PF_LOCAL
+#define AF_UNIX         AF_LOCAL
+#define AF_FILE         AF_LOCAL
+#define AF_INET         PF_INET
+#define AF_AX25         PF_AX25
+#define AF_IPX          PF_IPX
+#define AF_APPLETALK    PF_APPLETALK
+#define AF_NETROM       PF_NETROM
+#define AF_BRIDGE       PF_BRIDGE
+#define AF_ATMPVC       PF_ATMPVC
+#define AF_X25          PF_X25
+#define AF_INET6        PF_INET6
+#define AF_ROSE         PF_ROSE
+#define AF_DECnet       PF_DECnet
+#define AF_NETBEUI      PF_NETBEUI
+#define AF_SECURITY     PF_SECURITY
+#define AF_KEY          PF_KEY
+#define AF_NETLINK      PF_NETLINK
+#define AF_ROUTE        PF_ROUTE
+#define AF_PACKET       PF_PACKET
+#define AF_ASH          PF_ASH
+#define AF_ECONET       PF_ECONET
+#define AF_ATMSVC       PF_ATMSVC
+#define AF_RDS          PF_RDS
+#define AF_SNA          PF_SNA
+#define AF_IRDA         PF_IRDA
+#define AF_PPPOX        PF_PPPOX
+#define AF_WANPIPE      PF_WANPIPE
+#define AF_LLC          PF_LLC
+#define AF_IB           PF_IB
+#define AF_MPLS         PF_MPLS
+#define AF_CAN          PF_CAN
+#define AF_TIPC         PF_TIPC
+#define AF_BLUETOOTH    PF_BLUETOOTH
+#define AF_IUCV         PF_IUCV
+#define AF_RXRPC        PF_RXRPC
+#define AF_ISDN         PF_ISDN
+#define AF_PHONET       PF_PHONET
+#define AF_IEEE802154   PF_IEEE802154
+#define AF_CAIF         PF_CAIF
+#define AF_ALG          PF_ALG
+#define AF_NFC          PF_NFC
+#define AF_VSOCK        PF_VSOCK
+#define AF_KCM          PF_KCM
+#define AF_QIPCRTR      PF_QIPCRTR
+#define AF_SMC          PF_SMC
+#define AF_XDP          PF_XDP
+#define AF_MAX          PF_MAX
+
+#ifndef SO_DEBUG
+#define SO_DEBUG        1
+#define SO_REUSEADDR    2
+#define SO_TYPE         3
+#define SO_ERROR        4
+#define SO_DONTROUTE    5
+#define SO_BROADCAST    6
+#define SO_SNDBUF       7
+#define SO_RCVBUF       8
+#define SO_KEEPALIVE    9
+#define SO_OOBINLINE    10
+#define SO_NO_CHECK     11
+#define SO_PRIORITY     12
+#define SO_LINGER       13
+#define SO_BSDCOMPAT    14
+#define SO_REUSEPORT    15
+#define SO_PASSCRED     16
+#define SO_PEERCRED     17
+#define SO_RCVLOWAT     18
+#define SO_SNDLOWAT     19
+#define SO_ACCEPTCONN   30
+#define SO_PEERSEC      31
+#define SO_SNDBUFFORCE  32
+#define SO_RCVBUFFORCE  33
+#define SO_PROTOCOL     38
+#define SO_DOMAIN       39
+#endif
+
+#ifndef SO_RCVTIMEO
+#if __LONG_MAX == 0x7fffffff
+#define SO_RCVTIMEO     66
+#define SO_SNDTIMEO     67
+#else
+#define SO_RCVTIMEO     20
+#define SO_SNDTIMEO     21
+#endif
+#endif
+
+#ifndef SO_TIMESTAMP
+#if __LONG_MAX == 0x7fffffff
+#define SO_TIMESTAMP    63
+#define SO_TIMESTAMPNS  64
+#define SO_TIMESTAMPING 65
+#else
+#define SO_TIMESTAMP    29
+#define SO_TIMESTAMPNS  35
+#define SO_TIMESTAMPING 37
+#endif
+#endif
+
+#define SO_SECURITY_AUTHENTICATION              22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT        23
+#define SO_SECURITY_ENCRYPTION_NETWORK          24
+
+#define SO_BINDTODEVICE 25
+
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+#define SO_GET_FILTER           SO_ATTACH_FILTER
+
+#define SO_PEERNAME             28
+#define SCM_TIMESTAMP           SO_TIMESTAMP
+#define SO_PASSSEC              34
+#define SCM_TIMESTAMPNS         SO_TIMESTAMPNS
+#define SO_MARK                 36
+#define SCM_TIMESTAMPING        SO_TIMESTAMPING
+#define SO_RXQ_OVFL             40
+#define SO_WIFI_STATUS          41
+#define SCM_WIFI_STATUS         SO_WIFI_STATUS
+#define SO_PEEK_OFF             42
+#define SO_NOFCS                43
+#define SO_LOCK_FILTER          44
+#define SO_SELECT_ERR_QUEUE     45
+#define SO_BUSY_POLL            46
+#define SO_MAX_PACING_RATE      47
+#define SO_BPF_EXTENSIONS       48
+#define SO_INCOMING_CPU         49
+#define SO_ATTACH_BPF           50
+#define SO_DETACH_BPF           SO_DETACH_FILTER
+#define SO_ATTACH_REUSEPORT_CBPF 51
+#define SO_ATTACH_REUSEPORT_EBPF 52
+#define SO_CNX_ADVICE           53
+#define SCM_TIMESTAMPING_OPT_STATS 54
+#define SO_MEMINFO              55
+#define SO_INCOMING_NAPI_ID     56
+#define SO_COOKIE               57
+#define SCM_TIMESTAMPING_PKTINFO 58
+#define SO_PEERGROUPS           59
+#define SO_ZEROCOPY             60
+#define SO_TXTIME               61
+#define SCM_TXTIME              SO_TXTIME
+#define SO_BINDTOIFINDEX        62
+#define SO_DETACH_REUSEPORT_BPF 68
+
+#ifndef SOL_SOCKET
+#define SOL_SOCKET      1
+#endif
+
+#define SOL_IP          0
+#define SOL_IPV6        41
+#define SOL_ICMPV6      58
+
+#define SOL_RAW         255
+#define SOL_DECNET      261
+#define SOL_X25         262
+#define SOL_PACKET      263
+#define SOL_ATM         264
+#define SOL_AAL         265
+#define SOL_IRDA        266
+#define SOL_NETBEUI     267
+#define SOL_LLC         268
+#define SOL_DCCP        269
+#define SOL_NETLINK     270
+#define SOL_TIPC        271
+#define SOL_RXRPC       272
+#define SOL_PPPOL2TP    273
+#define SOL_BLUETOOTH   274
+#define SOL_PNPIPE      275
+#define SOL_RDS         276
+#define SOL_IUCV        277
+#define SOL_CAIF        278
+#define SOL_ALG         279
+#define SOL_NFC         280
+#define SOL_KCM         281
+#define SOL_TLS         282
+#define SOL_XDP         283
+
+#define SOMAXCONN       128
+
+#define MSG_OOB       0x0001
+#define MSG_PEEK      0x0002
+#define MSG_DONTROUTE 0x0004
+#define MSG_CTRUNC    0x0008
+#define MSG_PROXY     0x0010
+#define MSG_TRUNC     0x0020
+#define MSG_DONTWAIT  0x0040
+#define MSG_EOR       0x0080
+#define MSG_WAITALL   0x0100
+#define MSG_FIN       0x0200
+#define MSG_SYN       0x0400
+#define MSG_CONFIRM   0x0800
+#define MSG_RST       0x1000
+#define MSG_ERRQUEUE  0x2000
+#define MSG_NOSIGNAL  0x4000
+#define MSG_MORE      0x8000
+#define MSG_WAITFORONE 0x10000
+#define MSG_BATCH     0x40000
+#define MSG_ZEROCOPY  0x4000000
+#define MSG_FASTOPEN  0x20000000
+#define MSG_CMSG_CLOEXEC 0x40000000
+
+#define __CMSG_LEN(cmsg) (((cmsg)->cmsg_len + sizeof(long) - 1) & ~(long)(sizeof(long) - 1))
+#define __CMSG_NEXT(cmsg) ((unsigned char *)(cmsg) + __CMSG_LEN(cmsg))
+#define __MHDR_END(mhdr) ((unsigned char *)(mhdr)->msg_control + (mhdr)->msg_controllen)
+
+#define CMSG_DATA(cmsg) ((unsigned char *) (((struct cmsghdr *)(cmsg)) + 1))
+#define CMSG_NXTHDR(mhdr, cmsg) ((cmsg)->cmsg_len < sizeof (struct cmsghdr) || \
+	__CMSG_LEN(cmsg) + sizeof(struct cmsghdr) >= __MHDR_END(mhdr) - (unsigned char *)(cmsg) \
+	? 0 : (struct cmsghdr *)__CMSG_NEXT(cmsg))
+#define CMSG_FIRSTHDR(mhdr) ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr) ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
+
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+#define SCM_RIGHTS      0x01
+#define SCM_CREDENTIALS 0x02
+
+struct sockaddr {
+	sa_family_t sa_family;
+	char sa_data[14];
+};
+
+struct sockaddr_storage {
+	sa_family_t ss_family;
+	char __ss_padding[128-sizeof(long)-sizeof(sa_family_t)];
+	unsigned long __ss_align;
+};
+
+int socket (int, int, int);
+int socketpair (int, int, int, int [2]);
+
+int shutdown (int, int);
+
+int bind (int, const struct sockaddr *, socklen_t);
+int connect (int, const struct sockaddr *, socklen_t);
+int listen (int, int);
+int accept (int, struct sockaddr *__restrict, socklen_t *__restrict);
+int accept4(int, struct sockaddr *__restrict, socklen_t *__restrict, int);
+
+int getsockname (int, struct sockaddr *__restrict, socklen_t *__restrict);
+int getpeername (int, struct sockaddr *__restrict, socklen_t *__restrict);
+
+ssize_t send (int, const void *, size_t, int);
+ssize_t recv (int, void *, size_t, int);
+ssize_t sendto (int, const void *, size_t, int, const struct sockaddr *, socklen_t);
+ssize_t recvfrom (int, void *__restrict, size_t, int, struct sockaddr *__restrict, socklen_t *__restrict);
+ssize_t sendmsg (int, const struct msghdr *, int);
+ssize_t recvmsg (int, struct msghdr *, int);
+
+int getsockopt (int, int, int, void *__restrict, socklen_t *__restrict);
+int setsockopt (int, int, int, const void *, socklen_t);
+
+int sockatmark (int);
+
+#if _REDIR_TIME64
+#ifdef _GNU_SOURCE
+__REDIR(recvmmsg, __recvmmsg_time64);
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/kal/libc/newlib/porting/include/sys/statfs.h b/kal/libc/newlib/porting/include/sys/statfs.h
new file mode 100644
index 0000000..c6440a4
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/statfs.h
@@ -0,0 +1,30 @@
+#ifndef _ADAPT_SYS_STATFS_H
+#define _ADAPT_SYS_STATFS_H
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct __fsid_t {
+    int __val[2];
+} fsid_t;
+
+struct statfs {
+    unsigned long f_type, f_bsize;
+    fsblkcnt_t f_blocks, f_bfree, f_bavail;
+    fsfilcnt_t f_files, f_ffree;
+    fsid_t f_fsid;
+    unsigned long f_namelen, f_frsize, f_flags, f_spare[4];
+};
+
+int statfs (const char *, struct statfs *);
+int fstatfs (int, struct statfs *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ADAPT_SYS_STATFS_H */
diff --git a/kal/libc/newlib/porting/include/sys/uio.h b/kal/libc/newlib/porting/include/sys/uio.h
new file mode 100644
index 0000000..fc7618b
--- /dev/null
+++ b/kal/libc/newlib/porting/include/sys/uio.h
@@ -0,0 +1,40 @@
+#ifndef _ADAPT_SYS_UIO_H
+#define _ADAPT_SYS_UIO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "sys/features.h"
+#include "sys/types.h"
+
+    struct iovec {
+        void *iov_base;
+        size_t iov_len;
+    };
+
+#define UIO_MAXIOV 1024
+
+ssize_t readv (int, const struct iovec *, int);
+ssize_t writev (int, const struct iovec *, int);
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+ssize_t preadv (int, const struct iovec *, int, off_t);
+ssize_t pwritev (int, const struct iovec *, int, off_t);
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+#define preadv64 preadv
+#define pwritev64 pwritev
+#define off64_t off_t
+#endif
+#endif
+
+#ifdef _GNU_SOURCE
+ssize_t process_vm_writev(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long);
+ssize_t process_vm_readv(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ADAPT_SYS_UIO_H */
diff --git a/kal/libc/newlib/porting/include/time.h b/kal/libc/newlib/porting/include/time.h
new file mode 100644
index 0000000..16c7ec9
--- /dev/null
+++ b/kal/libc/newlib/porting/include/time.h
@@ -0,0 +1,10 @@
+#ifndef _ADAPT_TIME_H
+#define _ADAPT_TIME_H
+
+#define _timezone timezone
+#define __TM_GMTOFF __tm_gmtoff
+#define __TM_ZONE __tm_zone
+
+#include_next <time.h>
+
+#endif /* _ADAPT_TIME_H */
diff --git a/kal/libc/newlib/porting/src/fs_adapt.c b/kal/libc/newlib/porting/src/fs_adapt.c
new file mode 100644
index 0000000..3907ee0
--- /dev/null
+++ b/kal/libc/newlib/porting/src/fs_adapt.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_config.h"
+#include "los_fs.h"
+#include "stdarg.h"
+#include "dirent.h"
+#include "sys/mount.h"
+#include "sys/statfs.h"
+#include "sys/stat.h"
+#include "fs_mount.h"
+#include "unistd.h"
+
+int mount(const char *source, const char *target,
+              const char *filesystemtype, unsigned long mountflags,
+              const void *data)
+{
+    return LOS_FsMount(source, target, filesystemtype, mountflags, data);
+}
+
+int umount(const char *target)
+{
+    return LOS_FsUmount(target);
+}
+
+int umount2(const char *target, int flag)
+{
+    return LOS_FsUmount2(target, flag);
+}
+
+int _open(const char *path, int oflag, ...)
+{
+    va_list vaList;
+    va_start(vaList, oflag);
+    int ret;
+    ret = LOS_Open(path, oflag);
+    va_end(vaList);
+    return ret;
+}
+
+int _close(int fd)
+{
+    return LOS_Close(fd);
+}
+
+ssize_t _read(int fd, void *buf, size_t nbyte)
+{
+    return LOS_Read(fd, buf, nbyte);
+}
+
+ssize_t _write(int fd, const void *buf, size_t nbyte)
+{
+    return LOS_Write(fd, buf, nbyte);
+}
+
+off_t _lseek(int fd, off_t offset, int whence)
+{
+    return LOS_Lseek(fd, offset, whence);
+}
+
+int _unlink(const char *path)
+{
+    return LOS_Unlink(path);
+}
+
+int _fstat(int fd, struct stat *buf)
+{
+    return LOS_Fstat(fd, buf);
+}
+
+int _stat(const char *path, struct stat *buf)
+{
+    return LOS_Stat(path, buf);
+}
+
+int fsync(int fd)
+{
+    return LOS_Sync(fd);
+}
+
+int mkdir(const char *path, mode_t mode)
+{
+    return LOS_Mkdir(path, mode);
+}
+
+DIR *opendir(const char *dirName)
+{
+    return LOS_Opendir(dirName);
+}
+
+struct dirent *readdir(DIR *dir)
+{
+    return LOS_Readdir(dir);
+}
+
+int closedir(DIR *dir)
+{
+    return LOS_Closedir(dir);
+}
+
+int rmdir(const char *path)
+{
+    return LOS_Unlink(path);
+}
+
+int rename(const char *oldName, const char *newName)
+{
+    return LOS_Rename(oldName, newName);
+}
+
+int statfs(const char *path, struct statfs *buf)
+{
+    return LOS_Statfs(path, buf);
+}
+
+int ftruncate(int fd, off_t length)
+{
+    return LOS_Ftruncate(fd, length);
+}
diff --git a/kal/libc/newlib/porting/src/other_adapt.c b/kal/libc/newlib/porting/src/other_adapt.c
new file mode 100644
index 0000000..8084f7c
--- /dev/null
+++ b/kal/libc/newlib/porting/src/other_adapt.c
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "sys/cdefs.h"
+#include "stdio.h"
+#include "unistd.h"
+#include "stdlib.h"
+#include "pthread.h"
+#include "hal_trace.h"
+#include "securec.h"
+#include "los_config.h"
+#include "los_memory.h"
+
+
+void __wrap__free_r(struct _reent *reent, void *aptr)
+{
+    if (aptr == NULL) {
+        return;
+    }
+
+    LOS_MemFree(OS_SYS_MEM_ADDR, aptr);
+}
+
+// size_t __wrap__malloc_usable_size_r(struct _reent *reent, void *aptr)
+// {
+//     return 0;
+// }
+// 
+// void *__wrap__malloc_r(struct _reent *reent, size_t nbytes)
+// {
+//     if (nbytes == 0) {
+//         return NULL;
+//     }
+// 
+//     return LOS_MemAlloc(OS_SYS_MEM_ADDR, nbytes);
+// }
+// 
+// void *__wrap__memalign_r(struct _reent *reent, size_t align, size_t nbytes)
+// {
+//     if (nbytes == 0) {
+//         return NULL;
+//     }
+// 
+//     return LOS_MemAllocAlign(OS_SYS_MEM_ADDR, nbytes, align);
+// }
+// 
+// void *__wrap__realloc_r(struct _reent *reent, void *aptr, size_t nbytes)
+// {
+//     TRACE(0, "%s %d", __func__, __LINE__);
+//     if (aptr == NULL) {
+//         return malloc(nbytes);
+//     }
+// 
+//     if (nbytes == 0) {
+//         free(aptr);
+//         return NULL;
+//     }
+// 
+//     return LOS_MemRealloc(OS_SYS_MEM_ADDR, aptr, nbytes);
+// }
+
+int _isatty(int file)
+{
+    return file <= 2;
+}
+
+int _kill(int i, int j)
+{
+    return 0;
+}
+
+int _getpid(void)
+{
+    return 0;
+}
+
+void _exit(int status)
+{
+    write(1, "exit\n", 5);
+    (VOID)pthread_exit(&status);
+    while (1) {
+    }
+}
+
diff --git a/kal/libc/newlib/porting/src/realpath.c b/kal/libc/newlib/porting/src/realpath.c
new file mode 100644
index 0000000..9c630cb
--- /dev/null
+++ b/kal/libc/newlib/porting/src/realpath.c
@@ -0,0 +1,76 @@
+/* realpath.c - Return the canonicalized absolute pathname */
+
+/* Written 2000 by Werner Almesberger */
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <limits.h>
+#include <errno.h>
+#include <sys/stat.h>
+
+/* FIXME: buffer overrun possible, loops forever on cyclic symlinks */
+
+/*
+ * Canonical name: never ends with a slash
+ */
+
+static int resolve_path(char *path, char *result, char *pos)
+{
+    if (*path == '/') {
+        *result = '/';
+        pos = result + 1;
+        path++;
+    }
+    *pos = 0;
+    if (!*path)
+        return 0;
+    while (1) {
+        char *slash;
+        struct stat st;
+
+        slash = *path ? strchr(path, '/') : NULL;
+        if (slash)
+            *slash = 0;
+        if (!path[0] || (path[0] == '.' &&
+                         (!path[1] || (path[1] == '.' && !path[2])))) {
+            pos--;
+            if (pos != result && path[0] && path[1])
+                while (*--pos != '/')
+                    ;
+        } else {
+            strcpy(pos, path);
+            if (stat(result, &st) < 0)
+                return -1;
+            // ignore link
+            pos = strchr(result, 0);
+        }
+        if (slash) {
+            *pos++ = '/';
+            path = slash + 1;
+        }
+        *pos = 0;
+        if (!slash)
+            break;
+    }
+    return 0;
+}
+
+char *realpath(const char *__restrict path, char *__restrict resolved_path)
+{
+    char *path_copy;
+    int res;
+
+    if (!*path) {
+        errno = ENOENT; /* SUSv2 */
+        return NULL;
+    }
+    path_copy = strdup(path);
+    if (!path_copy)
+        return NULL;
+    res = resolve_path(path_copy, resolved_path, resolved_path);
+    free(path_copy);
+    if (res)
+        return NULL;
+    return resolved_path;
+}
diff --git a/kal/libc/newlib/porting/src/time_adapt.c b/kal/libc/newlib/porting/src/time_adapt.c
new file mode 100644
index 0000000..a585032
--- /dev/null
+++ b/kal/libc/newlib/porting/src/time_adapt.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2021-2021 Huawei Device Co., Ltd. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this list of
+ *    conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list
+ *    of conditions and the following disclaimer in the documentation and/or other materials
+ *    provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used
+ *    to endorse or promote products derived from this software without specific prior written
+ *    permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "los_tick.h"
+#include "time.h"
+#include "sys/time.h"
+
+#define SECS_PER_MIN 60
+
+int _gettimeofday(struct timeval *__tp, void *__tzp)
+{
+    struct timespec ts;
+    struct timezone *tz = (struct timezone *)__tzp;
+
+    if (__tp != NULL) {
+        if (-1 == clock_gettime(CLOCK_REALTIME, &ts)) {
+            return -1;
+        }
+        __tp->tv_sec = ts.tv_sec;
+        __tp->tv_usec = ts.tv_nsec / OS_SYS_NS_PER_US;
+    }
+    if (tz != NULL) {
+        tz->tz_minuteswest = timezone / SECS_PER_MIN;
+        tz->tz_dsttime = 0;
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/kal/posix/BUILD.gn b/kal/posix/BUILD.gn
index 8da2352..ab00c46 100644
--- a/kal/posix/BUILD.gn
+++ b/kal/posix/BUILD.gn
@@ -29,21 +29,40 @@
 
 import("//kernel/liteos_m/liteos.gni")
 
-module_switch = defined(LOSCFG_COMPAT_POSIX)
+module_switch = defined(LOSCFG_POSIX_API)
 module_name = get_path_info(rebase_path("."), "name")
 kernel_module(module_name) {
   sources = [
     "src/errno.c",
     "src/libc.c",
-    "src/malloc.c",
-    "src/mqueue.c",
-    "src/pthread.c",
-    "src/pthread_attr.c",
-    "src/pthread_cond.c",
-    "src/pthread_mutex.c",
-    "src/semaphore.c",
-    "src/time.c",
   ]
+
+  if (defined(LOSCFG_POSIX_THREAD_API)) {
+    sources += [
+      "src/pthread.c",
+      "src/pthread_cond.c",
+      "src/pthread_attr.c",
+      "src/pthread_mutex.c",
+    ]
+  }
+
+  if (defined(LOSCFG_POSIX_CLOCK_API)) {
+    sources += [
+      "src/time.c",
+    ]
+  }
+
+  if (defined(LOSCFG_POSIX_SEM_API)) {
+    sources += [
+      "src/semaphore.c",
+    ]
+  }
+
+  if (defined(LOSCFG_POSIX_MQUEUE_API)) {
+    sources += [
+#        "src/mqueue.c",
+    ]
+  }
 }
 
 config("public") {
diff --git a/kal/posix/Kconfig b/kal/posix/Kconfig
new file mode 100644
index 0000000..1ccaafc
--- /dev/null
+++ b/kal/posix/Kconfig
@@ -0,0 +1,62 @@
+# Copyright (c) 2013-2019 Huawei Technologies Co., Ltd. All rights reserved.
+# Copyright (c) 2020-2021 Huawei Device Co., Ltd. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice, this list of
+#    conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice, this list
+#    of conditions and the following disclaimer in the documentation and/or other materials
+#    provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its contributors may be used
+#    to endorse or promote products derived from this software without specific prior written
+#    permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+config POSIX_API
+    bool "Enable POSIX API"
+    default y
+    help
+      Answer Y to enable LiteOS support POSIX API.
+
+if POSIX_API
+
+config POSIX_THREAD_API
+    bool "Enable POSIX Thread API"
+    default y
+    help
+      Answer Y to enable LiteOS support POSIX Thread API.
+
+config POSIX_SEM_API
+    bool "Enable POSIX Semaphore API"
+    default y
+    help
+      Answer Y to enable LiteOS support POSIX Semaphore API.
+
+config POSIX_CLOCK_API
+    bool "Enable POSIX Semaphore API"
+    default y
+    help
+      Answer Y to enable LiteOS support POSIX Clock API.
+
+config POSIX_MQUEUE_API
+    bool "Enable POSIX Semaphore API"
+    default y
+    help
+      Answer Y to enable LiteOS support POSIX Mqueue API.
+
+endif # POSIX_API
diff --git a/kal/posix/src/pthread_cond.c b/kal/posix/src/pthread_cond.c
index 1ce795c..e7d62e6 100644
--- a/kal/posix/src/pthread_cond.c
+++ b/kal/posix/src/pthread_cond.c
@@ -100,7 +100,7 @@ STATIC INLINE INT32 CondInitCheck(const pthread_cond_t *cond)
 
 int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)
 {
-    int ret = ENOERR;
+    int ret = 0;
     pthread_condattr_t condAttr;
 
     if (cond == NULL) {
@@ -137,19 +137,19 @@ int pthread_cond_destroy(pthread_cond_t *cond)
     }
 
     if (CondInitCheck(cond)) {
-        return ENOERR;
+        return 0;
     }
 
     if (LOS_EventDestroy(&cond->event) != LOS_OK) {
         return EBUSY;
     }
-    if (pthread_mutex_destroy(cond->mutex) != ENOERR) {
+    if (pthread_mutex_destroy(cond->mutex) != 0) {
         PRINT_ERR("%s mutex destroy fail!\n", __FUNCTION__);
         return EINVAL;
     }
     free(cond->mutex);
     cond->mutex = NULL;
-    return ENOERR;
+    return 0;
 }
 
 STATIC VOID PthreadCountSub(pthread_cond_t *cond)
@@ -164,7 +164,7 @@ STATIC VOID PthreadCountSub(pthread_cond_t *cond)
 
 int pthread_cond_broadcast(pthread_cond_t *cond)
 {
-    int ret = ENOERR;
+    int ret = 0;
 
     if (cond == NULL) {
         return EINVAL;
@@ -184,7 +184,7 @@ int pthread_cond_broadcast(pthread_cond_t *cond)
 
 int pthread_cond_signal(pthread_cond_t *cond)
 {
-    int ret = ENOERR;
+    int ret = 0;
 
     if (cond == NULL) {
         return EINVAL;
@@ -211,7 +211,7 @@ STATIC INT32 ProcessReturnVal(pthread_cond_t *cond, INT32 val)
         /* 0: event does not occur */
         case 0:
         case BROADCAST_EVENT:
-            ret = ENOERR;
+            ret = 0;
             break;
         case LOS_ERRNO_EVENT_READ_TIMEOUT:
             PthreadCountSub(cond);
@@ -241,7 +241,7 @@ int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 
     if (CondInitCheck(cond)) {
         ret = pthread_cond_init(cond, NULL);
-        if (ret != ENOERR) {
+        if (ret != 0) {
             return ret;
         }
     }
@@ -265,13 +265,13 @@ int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
         return EINVAL;
     }
 
-    if (pthread_mutex_unlock(mutex) != ENOERR) {
+    if (pthread_mutex_unlock(mutex) != 0) {
         PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
     }
 
     ret = (INT32)LOS_EventRead(&(cond->event), 0x0f, LOS_WAITMODE_OR | LOS_WAITMODE_CLR, absTicks);
 
-    if (pthread_mutex_lock(mutex) != ENOERR) {
+    if (pthread_mutex_lock(mutex) != 0) {
         PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
     }
 
@@ -289,7 +289,7 @@ int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
 
     if (CondInitCheck(cond)) {
         ret = pthread_cond_init(cond, NULL);
-        if (ret != ENOERR) {
+        if (ret != 0) {
             return ret;
         }
     }
@@ -298,11 +298,11 @@ int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
     cond->count++;
     (VOID)pthread_mutex_unlock(cond->mutex);
 
-    if (pthread_mutex_unlock(mutex) != ENOERR) {
+    if (pthread_mutex_unlock(mutex) != 0) {
         PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
     }
     ret = (INT32)LOS_EventRead(&(cond->event), 0x0f, LOS_WAITMODE_OR | LOS_WAITMODE_CLR, LOS_WAIT_FOREVER);
-    if (pthread_mutex_lock(mutex) != ENOERR) {
+    if (pthread_mutex_lock(mutex) != 0) {
         PRINT_ERR("%s: %d failed\n", __FUNCTION__, __LINE__);
     }
 
@@ -310,7 +310,7 @@ int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
         /* 0: event does not occur */
         case 0:
         case BROADCAST_EVENT:
-            ret = ENOERR;
+            ret = 0;
             break;
         default:
             PthreadCountSub(cond);
diff --git a/kal/posix/src/time.c b/kal/posix/src/time.c
index 0f54fca..52e4eb9 100644
--- a/kal/posix/src/time.c
+++ b/kal/posix/src/time.c
@@ -29,7 +29,7 @@
  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#define _GNU_SOURCE
+#define _GNU_SOURCE 1
 #include <time.h>
 #include <sys/time.h>
 #include <stdint.h>
@@ -47,6 +47,7 @@
 /* accumulative time delta from discontinuous modify */
 STATIC struct timespec g_accDeltaFromSet;
 
+#ifndef __USE_NEWLIB__
 STATIC const UINT16 g_daysInMonth[2][13] = {
     /* Normal years.  */
     { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
@@ -56,6 +57,10 @@ STATIC const UINT16 g_daysInMonth[2][13] = {
 
 STATIC const UINT8 g_montbl[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 
+/* internal shared struct tm object for localtime and gmtime */
+static struct tm g_tm;
+#endif
+
 /*
  * Time zone information, stored in seconds,
  * negative values indicate the east of UTC,
@@ -63,9 +68,6 @@ STATIC const UINT8 g_montbl[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,
  */
 long timezone = -8 * 60 * 60; // defaults to CST: 8 hours east of the Prime Meridian
 
-/* internal shared struct tm object for localtime and gmtime */
-static struct tm g_tm;
-
 int nanosleep(const struct timespec *rqtp, struct timespec *rmtp)
 {
     UINT64 nseconds;
@@ -295,10 +297,18 @@ int clock_settime(clockid_t clockID, const struct timespec *tp)
         case CLOCK_MONOTONIC_RAW:
         case CLOCK_PROCESS_CPUTIME_ID:
         case CLOCK_BOOTTIME:
+#ifdef CLOCK_REALTIME_ALARM
         case CLOCK_REALTIME_ALARM:
+#endif
+#ifdef CLOCK_BOOTTIME_ALARM
         case CLOCK_BOOTTIME_ALARM:
+#endif
+#ifdef CLOCK_SGI_CYCLE
         case CLOCK_SGI_CYCLE:
+#endif
+#ifdef CLOCK_TAI
         case CLOCK_TAI:
+#endif
         case CLOCK_THREAD_CPUTIME_ID:
             errno = ENOTSUP;
             return -1;
@@ -329,10 +339,18 @@ int clock_gettime(clockid_t clockID, struct timespec *tp)
         case CLOCK_THREAD_CPUTIME_ID:
         case CLOCK_PROCESS_CPUTIME_ID:
         case CLOCK_BOOTTIME:
+#ifdef CLOCK_REALTIME_ALARM
         case CLOCK_REALTIME_ALARM:
+#endif
+#ifdef CLOCK_BOOTTIME_ALARM
         case CLOCK_BOOTTIME_ALARM:
+#endif
+#ifdef CLOCK_SGI_CYCLE
         case CLOCK_SGI_CYCLE:
+#endif
+#ifdef CLOCK_TAI
         case CLOCK_TAI:
+#endif
             errno = ENOTSUP;
             return -1;
         default:
@@ -360,10 +378,18 @@ int clock_getres(clockid_t clockID, struct timespec *tp)
         case CLOCK_THREAD_CPUTIME_ID:
         case CLOCK_PROCESS_CPUTIME_ID:
         case CLOCK_BOOTTIME:
+#ifdef CLOCK_REALTIME_ALARM
         case CLOCK_REALTIME_ALARM:
+#endif
+#ifdef CLOCK_BOOTTIME_ALARM
         case CLOCK_BOOTTIME_ALARM:
+#endif
+#ifdef CLOCK_SGI_CYCLE
         case CLOCK_SGI_CYCLE:
+#endif
+#ifdef CLOCK_TAI
         case CLOCK_TAI:
+#endif
             errno = ENOTSUP;
             return -1;
         default:
@@ -387,10 +413,18 @@ int clock_nanosleep(clockid_t clk, int flags, const struct timespec *req, struct
         case CLOCK_MONOTONIC:
         case CLOCK_PROCESS_CPUTIME_ID:
         case CLOCK_BOOTTIME:
+#ifdef CLOCK_REALTIME_ALARM
         case CLOCK_REALTIME_ALARM:
+#endif
+#ifdef CLOCK_BOOTTIME_ALARM
         case CLOCK_BOOTTIME_ALARM:
+#endif
+#ifdef CLOCK_SGI_CYCLE
         case CLOCK_SGI_CYCLE:
+#endif
+#ifdef CLOCK_TAI
         case CLOCK_TAI:
+#endif
             if (flags == 0 || flags == TIMER_ABSTIME) {
                 return ENOTSUP;
             }
@@ -426,7 +460,7 @@ time_t time(time_t *timer)
     }
     return ts.tv_sec;
 }
-
+#ifndef __USE_NEWLIB__
 /*
  * Compute the `struct tm' representation of T,
  * offset OFFSET seconds east of UTC,
@@ -588,7 +622,9 @@ time_t mktime(struct tm *tmptr)
     ConvertSecs2Utc(timeInSeconds, tmptr->__tm_gmtoff, tmptr);
     return timeInSeconds;
 }
+#endif
 
+#ifndef __USE_NEWLIB__
 int gettimeofday(struct timeval *tv, void *ptz)
 {
     struct timespec ts;
@@ -607,6 +643,7 @@ int gettimeofday(struct timeval *tv, void *ptz)
     }
     return 0;
 }
+#endif
 
 int settimeofday(const struct timeval *tv, const struct timezone *tz)
 {
@@ -643,7 +680,7 @@ int settimeofday(const struct timeval *tv, const struct timezone *tz)
     return 0;
 }
 
-int usleep(unsigned useconds)
+int usleep(useconds_t useconds)
 {
     struct timespec specTime = { 0 };
     UINT64 nanoseconds = (UINT64)useconds * OS_SYS_NS_PER_US;
diff --git a/kernel/src/los_init.c b/kernel/src/los_init.c
index d2b13a3..3022588 100644
--- a/kernel/src/los_init.c
+++ b/kernel/src/los_init.c
@@ -181,6 +181,14 @@ LITE_OS_SEC_TEXT_INIT UINT32 LOS_KernelInit(VOID)
     }
 #endif
 
+#if (LOSCFG_FS_VFS == 1)
+    ret = LOS_VfsInit();
+    if (ret != LOS_OK) {
+        PRINT_ERR("LOS_VfsInit error\n");
+        return ret;
+    }
+#endif
+
     ret = OsIdleTaskCreate();
     if (ret != LOS_OK) {
         return ret;
-- 
2.17.1

